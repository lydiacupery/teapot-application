<?xml version="1.0"?>
<doc>
    <assembly>
        <name>ReactiveUI</name>
    </assembly>
    <members>
        <member name="T:ReactiveUI.KVOObservableForProperty">
            <summary>
            This class provides notifications for Cocoa Framework objects based on
            Key-Value Observing. Unfortunately, this class is a bit Trickyâ„¢, because
            of the caveat mentioned below - there is no way up-front to be able to
            tell whether a given property on an object is Key-Value Observable, we 
            only have to hope for the best :-/
            </summary>
        </member>
        <member name="T:ReactiveUI.NSRunloopScheduler">
            <summary>
            Provides a scheduler which will use the Cocoa main loop to schedule
            work on. This is the Cocoa equivalent of DispatcherScheduler.
            </summary>
        </member>
        <member name="T:ReactiveUI.TargetActionCommandBinder">
            <summary>
            TargetActionCommandBinder is an implementation of command binding that
            understands Cocoa's Target / Action Framework. Many controls in Cocoa 
            that are effectively command sources (i.e. Buttons, Menus, etc), 
            participate in this framework.
            </summary>
        </member>
        <member name="T:ReactiveUI.ViewModelViewHostLegacy">
            <summary>
            ViewModelViewHost is a helper class that will connect a ViewModel
            to an arbitrary NSView and attempt to load the View for the current
            ViewModel as a child view of the target. 
            
            This is a bit different than the XAML's ViewModelViewHost in the sense
            that this isn't a Control itself, it only manipulates other Views.
            </summary>
        </member>
        <member name="P:ReactiveUI.ViewModelViewHostLegacy.AddAutoLayoutConstraintsToSubView">
            <summary>
            Gets or sets a value indicating whether this <see cref="!:ReactiveUI.Cocoa.ViewModelViewHost"/>
            will automatically create Auto Layout constraints tying the sub view to the parent view.
            </summary>
            <value><c>true</c> if add layout contraints to sub view; otherwise, <c>false</c>.</value>
        </member>
        <member name="T:ReactiveUI.ComponentModelTypeConverter">
            <summary>
            This binding type converter uses the built-in WPF component model 
            conversions to get a whole bunch of conversions for free. Unfortunately,
            these are pretty gutted on some other platforms like Silverlight.
            </summary>
        </member>
        <member name="T:ReactiveUI.PlatformRegistrations">
            <summary>
            Ignore me. This class is a secret handshake between RxUI and RxUI.Xaml
            in order to register certain classes on startup that would be difficult
            to register otherwise.
            </summary>
        </member>
        <member name="T:ReactiveUI.PlatformOperations">
            <summary>
            Returns the current orientation of the device on iOS.
            </summary>
        </member>
        <member name="T:ReactiveUI.ReactiveView">
            <summary>
            This is an View that is both an NSView and has ReactiveObject powers 
            (i.e. you can call RaiseAndSetIfChanged)
            </summary>
        </member>
        <member name="P:ReactiveUI.ReactiveView.Changing">
            <summary>
            Represents an Observable that fires *before* a property is about to
            be changed.         
            </summary>
        </member>
        <member name="P:ReactiveUI.ReactiveView.Changed">
            <summary>
            Represents an Observable that fires *after* a property has changed.
            </summary>
        </member>
        <member name="M:ReactiveUI.ReactiveView.SuppressChangeNotifications">
            <summary>
            When this method is called, an object will not fire change
            notifications (neither traditional nor Observable notifications)
            until the return value is disposed.
            </summary>
            <returns>An object that, when disposed, reenables change
            notifications.</returns>
        </member>
        <member name="T:ReactiveUI.ReactiveViewController">
            <summary>
            This is an View that is both an NSViewController and has ReactiveObject powers 
            (i.e. you can call RaiseAndSetIfChanged)
            </summary>
        </member>
        <member name="P:ReactiveUI.ReactiveViewController.Changing">
            <summary>
            Represents an Observable that fires *before* a property is about to
            be changed.         
            </summary>
        </member>
        <member name="P:ReactiveUI.ReactiveViewController.Changed">
            <summary>
            Represents an Observable that fires *after* a property has changed.
            </summary>
        </member>
        <member name="M:ReactiveUI.ReactiveViewController.SuppressChangeNotifications">
            <summary>
            When this method is called, an object will not fire change
            notifications (neither traditional nor Observable notifications)
            until the return value is disposed.
            </summary>
            <returns>An object that, when disposed, reenables change
            notifications.</returns>
        </member>
        <member name="P:ReactiveUI.ReactiveImageView.Changing">
            <summary>
            Represents an Observable that fires *before* a property is about to
            be changed.         
            </summary>
        </member>
        <member name="P:ReactiveUI.ReactiveImageView.Changed">
            <summary>
            Represents an Observable that fires *after* a property has changed.
            </summary>
        </member>
        <member name="P:ReactiveUI.ReactiveControl.Changing">
            <summary>
            Represents an Observable that fires *before* a property is about to
            be changed.
            </summary>
        </member>
        <member name="P:ReactiveUI.ReactiveControl.Changed">
            <summary>
            Represents an Observable that fires *after* a property has changed.
            </summary>
        </member>
        <member name="M:ReactiveUI.ReactiveControl.SuppressChangeNotifications">
            <summary>
            When this method is called, an object will not fire change
            notifications (neither traditional nor Observable notifications)
            until the return value is disposed.
            </summary>
            <returns>An object that, when disposed, reenables change
            notifications.</returns>
        </member>
        <member name="P:ReactiveUI.ReactiveWindowController.Changing">
            <summary>
            Represents an Observable that fires *before* a property is about to
            be changed.         
            </summary>
        </member>
        <member name="P:ReactiveUI.ReactiveWindowController.Changed">
            <summary>
            Represents an Observable that fires *after* a property has changed.
            </summary>
        </member>
        <member name="M:ReactiveUI.ReactiveWindowController.SuppressChangeNotifications">
            <summary>
            When this method is called, an object will not fire change
            notifications (neither traditional nor Observable notifications)
            until the return value is disposed.
            </summary>
            <returns>An object that, when disposed, reenables change
            notifications.</returns>
        </member>
        <member name="T:ReactiveUI.ViewModelActivator">
             <summary>
             ViewModelActivator is a helper class that you instantiate in your
             ViewModel classes in order to help with Activation. Views will internally
             call this class when the corresponding View comes on screen. This means
             you can set up resources such as subscriptions to global objects that
             should be cleaned up on exit. Once you instantiate this class, use the
             WhenActivated method to register what to do when activated.
            
             View Activation is  **not** the same as being loaded / unloaded; Views
             are Activated when they *enter* the Visual Tree, and are Deactivated when
             they *leave* the Visual Tree. This is a critical difference when it comes
             to views that are recycled, such as UITableViews or Virtualizing
             ScrollViews.
            
             Create this class solely in the **Base Class** of any classes that inherit
             from this class (i.e. if you create a FooViewModel that supports activation,
             the instance should be protected and a child BarViewModel should use the
             existing ViewModelActivator).
            
             NOTE: You **must** set up Activation in the corresponding View when using
             ViewModel Activation.
             </summary>
        </member>
        <member name="P:ReactiveUI.ViewModelActivator.Activated">
            <summary>
            Activated observable will tick every time the Activator is activated.
            </summary>
            <value>The activated.</value>
        </member>
        <member name="P:ReactiveUI.ViewModelActivator.Deactivated">
            <summary>
            Deactivated observable will tick every time the Activator is deactivated.
            </summary>
            <value>The deactivated.</value>
        </member>
        <member name="M:ReactiveUI.ViewModelActivator.#ctor">
            <summary>
            Constructs a new ViewModelActivator
            </summary>
        </member>
        <member name="M:ReactiveUI.ViewModelActivator.Activate">
            <summary>
            This method is called by the framework when the corresponding View
            is activated. Call this method in unit tests to simulate a ViewModel
            being activated.
            </summary>
            <returns>A Disposable that calls Deactivate when disposed.</returns>
        </member>
        <member name="M:ReactiveUI.ViewModelActivator.Deactivate(System.Boolean)">
            <summary>
            This method is called by the framework when the corresponding View
            is deactivated.
            </summary>
            <param name="ignoreRefCount">
            Force the VM to be deactivated, even
            if more than one person called Activate.
            </param>
        </member>
        <member name="T:ReactiveUI.ViewForMixins">
            <summary>
            A set of extension methods to help wire up View and ViewModel activation
            </summary>
        </member>
        <member name="M:ReactiveUI.ViewForMixins.WhenActivated(ReactiveUI.ISupportsActivation,System.Func{System.Collections.Generic.IEnumerable{System.IDisposable}})">
            <summary>
            WhenActivated allows you to register a Func to be called when a
            ViewModel's View is Activated.
            </summary>
            <param name="This">Object that supports activation.</param>
            <param name="block">
            The method to be called when the corresponding
            View is activated. It returns a list of Disposables that will be
            cleaned up when the View is deactivated.
            </param>
        </member>
        <member name="M:ReactiveUI.ViewForMixins.WhenActivated(ReactiveUI.ISupportsActivation,System.Action{System.Action{System.IDisposable}})">
            <summary>
            WhenActivated allows you to register a Func to be called when a
            ViewModel's View is Activated.
            </summary>
            <param name="This">Object that supports activation.</param>
            <param name="block">
            The method to be called when the corresponding
            View is activated. The Action parameter (usually called 'd') allows
            you to register Disposables to be cleaned up when the View is
            deactivated (i.e. "d(someObservable.Subscribe());")
            </param>
        </member>
        <member name="M:ReactiveUI.ViewForMixins.WhenActivated(ReactiveUI.ISupportsActivation,System.Action{System.Reactive.Disposables.CompositeDisposable})">
            <summary>
            WhenActivated allows you to register a Func to be called when a
            ViewModel's View is Activated.
            </summary>
            <param name="This">Object that supports activation.</param>
            <param name="block">
            The method to be called when the corresponding
            View is activated. The Action parameter (usually called 'disposables') allows
            you to collate all the disposables to be cleaned up during deactivation.
            </param>
        </member>
        <member name="M:ReactiveUI.ViewForMixins.WhenActivated(ReactiveUI.IActivatable,System.Func{System.Collections.Generic.IEnumerable{System.IDisposable}})">
            <summary>
            WhenActivated allows you to register a Func to be called when a
            View is Activated.
            </summary>
            <param name="This">Object that supports activation.</param>
            <param name="block">
            The method to be called when the corresponding
            View is activated. It returns a list of Disposables that will be
            cleaned up when the View is deactivated.
            </param>
            <returns>A Disposable that deactivates this registration.</returns>
        </member>
        <member name="M:ReactiveUI.ViewForMixins.WhenActivated(ReactiveUI.IActivatable,System.Func{System.Collections.Generic.IEnumerable{System.IDisposable}},ReactiveUI.IViewFor)">
            <summary>
            WhenActivated allows you to register a Func to be called when a
            View is Activated.
            </summary>
            <param name="This">Object that supports activation.</param>
            <param name="block">
            The method to be called when the corresponding
            View is activated. It returns a list of Disposables that will be
            cleaned up when the View is deactivated.
            </param>
            <param name="view">
            The IActivatable will ordinarily also host the View
            Model, but in the event it is not, a class implementing <see cref="T:ReactiveUI.IViewFor" />
            can be supplied here.
            </param>
            <returns>A Disposable that deactivates this registration.</returns>
        </member>
        <member name="M:ReactiveUI.ViewForMixins.WhenActivated(ReactiveUI.IActivatable,System.Action{System.Action{System.IDisposable}})">
            <summary>
            WhenActivated allows you to register a Func to be called when a
            View is Activated.
            </summary>
            <param name="This">Object that supports activation.</param>
            <param name="block">
            The method to be called when the corresponding
            View is activated. The Action parameter (usually called 'd') allows
            you to register Disposables to be cleaned up when the View is
            deactivated (i.e. "d(someObservable.Subscribe());")
            </param>
            <returns>A Disposable that deactivates this registration.</returns>
        </member>
        <member name="M:ReactiveUI.ViewForMixins.WhenActivated(ReactiveUI.IActivatable,System.Action{System.Action{System.IDisposable}},ReactiveUI.IViewFor)">
            <summary>
            WhenActivated allows you to register a Func to be called when a
            View is Activated.
            </summary>
            <param name="This">Object that supports activation.</param>
            <param name="block">
            The method to be called when the corresponding
            View is activated. The Action parameter (usually called 'd') allows
            you to register Disposables to be cleaned up when the View is
            deactivated (i.e. "d(someObservable.Subscribe());")
            </param>
            <param name="view">
            The IActivatable will ordinarily also host the View
            Model, but in the event it is not, a class implementing <see cref="T:ReactiveUI.IViewFor" />
            can be supplied here.
            </param>
            <returns>A Disposable that deactivates this registration.</returns>
        </member>
        <member name="M:ReactiveUI.ViewForMixins.WhenActivated(ReactiveUI.IActivatable,System.Action{System.Reactive.Disposables.CompositeDisposable},ReactiveUI.IViewFor)">
            <summary>
            WhenActivated allows you to register a Func to be called when a
            View is Activated.
            </summary>
            <param name="This">Object that supports activation.</param>
            <param name="block">
            The method to be called when the corresponding
            View is activated. The Action parameter (usually called 'disposables') allows
            you to collate all disposables that should be cleaned up during deactivation.
            </param>
            <param name="view">
            The IActivatable will ordinarily also host the View
            Model, but in the event it is not, a class implementing <see cref="T:ReactiveUI.IViewFor" />
            can be supplied here.
            </param>
            <returns>A Disposable that deactivates this registration.</returns>
        </member>
        <member name="T:ReactiveUI.CanActivateViewFetcher">
            <summary>
            This class implements View Activation for classes that explicitly describe
            their activation via <see cref="T:ReactiveUI.ICanActivate"/>. This class is used by the framework.
            </summary>
        </member>
        <member name="M:ReactiveUI.CanActivateViewFetcher.GetAffinityForView(System.Type)">
            <summary>
            Returns a positive integer for derivates of the <see cref="T:ReactiveUI.ICanActivate"/> interface.
            </summary>
            <param name="view">The source type to check</param>
            <returns>
            A positive integer if <see cref="M:ReactiveUI.CanActivateViewFetcher.GetActivationForView(ReactiveUI.IActivatable)"/> is supported, 
            zero otherwise
            </returns>
        </member>
        <member name="M:ReactiveUI.CanActivateViewFetcher.GetActivationForView(ReactiveUI.IActivatable)">
            <summary>
            Get an observable defining whether the view is active
            </summary>
            <param name="view">The view to observe</param>
            <returns>An observable tracking whether the view is active</returns>
        </member>
        <member name="T:ReactiveUI.IReactiveBinding`3">
            <summary>
            This interface represents the result of a Bind/OneWayBind and gives
            information about the binding. When this object is disposed, it will
            destroy the binding it is describing (i.e. most of the time you won't
            actually care about this object, just that it is disposable)
            </summary>
        </member>
        <member name="P:ReactiveUI.IReactiveBinding`3.ViewModel">
            <summary>
            The instance of the view model this binding is applied to.
            </summary>
            <value>
            The view model.
            </value>
        </member>
        <member name="P:ReactiveUI.IReactiveBinding`3.ViewModelExpression">
            <summary>
            An expression representing the propertyon the viewmodel bound to the view.
            This can be a child property, for example x.Foo.Bar.Baz in which case
            that will be the expression.
            </summary>
            <value>
            The expression.
            </value>
        </member>
        <member name="P:ReactiveUI.IReactiveBinding`3.View">
            <summary>
            The instance of the view this binding is applied to.
            </summary>
            <value>
            The view.
            </value>
        </member>
        <member name="P:ReactiveUI.IReactiveBinding`3.ViewExpression">
            <summary>
            An expression representing the property on the view bound to the viewmodel.
            This can be a child property, for example x.Foo.Bar.Baz in which case
            that will be the expression.
            </summary>
            <value>
            The expression.
            </value>
        </member>
        <member name="P:ReactiveUI.IReactiveBinding`3.Changed">
            <summary>
            An observable representing changed values for the binding.
            </summary>
            <value>
            The changed.
            </value>
        </member>
        <member name="P:ReactiveUI.IReactiveBinding`3.Direction">
            <summary>
            Gets the direction of the binding.
            </summary>
            <value>
            The direction.
            </value>
        </member>
        <member name="P:ReactiveUI.ReactiveBinding`3.ViewModel">
            <summary>
            The instance of the view model this binding is applied to.
            </summary>
            <value>
            The view model.
            </value>
        </member>
        <member name="P:ReactiveUI.ReactiveBinding`3.ViewModelExpression">
            <summary>
            An expression representing the propertyon the viewmodel bound to the view.
            This can be a child property, for example x.Foo.Bar.Baz in which case
            that will be the expression.
            </summary>
            <value>
            The expression.
            </value>
        </member>
        <member name="P:ReactiveUI.ReactiveBinding`3.View">
            <summary>
            The instance of the view this binding is applied to.
            </summary>
            <value>
            The view.
            </value>
        </member>
        <member name="P:ReactiveUI.ReactiveBinding`3.ViewExpression">
            <summary>
            An expression representing the property on the view bound to the viewmodel.
            This can be a child property, for example x.Foo.Bar.Baz in which case
            that will be the expression.
            </summary>
            <value>
            The expression.
            </value>
        </member>
        <member name="P:ReactiveUI.ReactiveBinding`3.Changed">
            <summary>
            An observable representing changed values for the binding.
            </summary>
            <value>
            The changed.
            </value>
        </member>
        <member name="P:ReactiveUI.ReactiveBinding`3.Direction">
            <summary>
            Gets the direction of the binding.
            </summary>
            <value>
            The direction.
            </value>
        </member>
        <member name="M:ReactiveUI.AutoPersistHelper.AutoPersist``1(``0,System.Func{``0,System.IObservable{System.Reactive.Unit}},System.Nullable{System.TimeSpan})">
            <summary>
            AutoPersist allows you to automatically call a method when an object
            has changed, throttling on a certain interval. Note that this object
            must mark its persistable properties via the [DataMember] attribute.
            Changes to properties not marked with DataMember will not trigger the
            object to be saved.
            </summary>
            <param name="This">
            The reactive object to watch for changes
            </param>
            <param name="doPersist">
            The asynchronous method to call to save the object to disk.
            </param>
            <param name="interval">
            The interval to save the object on. Note that if an object is constantly changing, 
            it is possible that it will never be saved.
            </param>
            <returns>A Disposable to disable automatic persistence.</returns>
        </member>
        <member name="M:ReactiveUI.AutoPersistHelper.AutoPersist``2(``0,System.Func{``0,System.IObservable{System.Reactive.Unit}},System.IObservable{``1},System.Nullable{System.TimeSpan})">
            <summary>
            AutoPersist allows you to automatically call a method when an object
            has changed, throttling on a certain interval. Note that this object
            must mark its persistable properties via the [DataMember] attribute.
            Changes to properties not marked with DataMember will not trigger the
            object to be saved.
            </summary>
            <param name="This">
            The reactive object to watch for changes
            </param>
            <param name="doPersist">
            The asynchronous method to call to save the object to disk.
            </param>
            <param name="manualSaveSignal">
            When invoked, the object will be saved regardless of whether it has changed.
            </param>
            <param name="interval">
            The interval to save the object on. Note that if an object is constantly changing, 
            it is possible that it will never be saved.
            </param>
            <returns>A Disposable to disable automatic persistence.</returns>
        </member>
        <member name="M:ReactiveUI.AutoPersistHelper.AutoPersistCollection``1(ReactiveUI.IReactiveCollection{``0},System.Func{``0,System.IObservable{System.Reactive.Unit}},System.Nullable{System.TimeSpan})">
            <summary>
            Apply AutoPersistence to all objects in a collection. Items that are
            no longer in the collection won't be persisted anymore.
            </summary>
            <param name="This">
            The reactive collection to watch for changes
            </param>
            <param name="doPersist">
            The asynchronous method to call to save the object to disk.
            </param>
            <param name="interval">
            The interval to save the object on. Note that if an object is constantly changing, 
            it is possible that it will never be saved.
            </param>
            <returns>A Disposable to disable automatic persistence.</returns>
        </member>
        <member name="M:ReactiveUI.AutoPersistHelper.AutoPersistCollection``2(ReactiveUI.IReactiveCollection{``0},System.Func{``0,System.IObservable{System.Reactive.Unit}},System.IObservable{``1},System.Nullable{System.TimeSpan})">
            <summary>
            Apply AutoPersistence to all objects in a collection. Items that are
            no longer in the collection won't be persisted anymore.
            </summary>
            <param name="This">
            The reactive collection to watch for changes
            </param>
            <param name="doPersist">
            The asynchronous method to call to save the object to disk.
            </param>
            <param name="manualSaveSignal">
            When invoked, the object will be saved regardless of whether it has changed.
            </param>
            <param name="interval">
            The interval to save the object on. Note that if an object is constantly changing, 
            it is possible that it will never be saved.
            </param>
            <returns>A Disposable to disable automatic persistence.</returns>
        </member>
        <member name="M:ReactiveUI.AutoPersistHelper.ActOnEveryObject``1(ReactiveUI.IReactiveCollection{``0},System.Action{``0},System.Action{``0})">
            <summary>
            Call methods 'onAdd' and 'onRemove' whenever an object is added or
            removed from a collection. This class correctly handles both when
            a collection is initialized, as well as when the collection is Reset.
            </summary>
            <param name="This">
            The reactive collection to watch for changes
            </param>
            <param name="onAdd">
            A method to be called when an object is added to the collection.
            </param>
            <param name="onRemove">
            A method to be called when an object is removed from the collection.
            </param>
            <returns>A Disposable that deactivates this behavior.</returns>
        </member>
        <member name="T:ReactiveUI.EqualityTypeConverter">
            <summary>
            The default converter, simply converts between types that are equal or
            can be converted (i.e. Button => UIControl)
            </summary>
        </member>
        <member name="T:ReactiveUI.StringConverter">
            <summary>
            Calls ToString on types. In WPF, ComponentTypeConverter should win
            instead of this, since It's Betterâ„¢.
            </summary>
        </member>
        <member name="T:ReactiveUI.CommandBinder">
            <summary>
            Various helpers to bind View controls and ViewModel commands together
            </summary>
        </member>
        <member name="M:ReactiveUI.CommandBinder.BindCommand``5(``0,``1,System.Linq.Expressions.Expression{System.Func{``1,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.IObservable{``4},System.String)">
            <summary>
            Bind a command from the ViewModel to an explicitly specified control
            on the View.
            </summary>
            <returns>A class representing the binding. Dispose it to disconnect
            the binding</returns>
            <param name="view">The View</param>
            <param name="viewModel">The View model</param>
            <param name="controlName">The name of the control on the view</param>
            <param name="propertyName">The ViewModel command to bind.</param>
            <param name="withParameter">The ViewModel property to pass as the
            param of the ICommand</param>
            <param name="toEvent">If specified, bind to the specific event
            instead of the default.</param>
        </member>
        <member name="M:ReactiveUI.CommandBinder.BindCommand``4(``0,``1,System.Linq.Expressions.Expression{System.Func{``1,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.String)">
            <summary>
            Bind a command from the ViewModel to an explicitly specified control
            on the View.
            </summary>
            <returns>A class representing the binding. Dispose it to disconnect
            the binding</returns>
            <param name="view">The View</param>
            <param name="viewModel">The View model</param>
            <param name="propertyName">The ViewModel command to bind</param>
            <param name="controlName">The name of the control on the view</param>
            <param name="toEvent">If specified, bind to the specific event
            instead of the default.</param>
        </member>
        <member name="M:ReactiveUI.CommandBinder.BindCommand``5(``0,``1,System.Linq.Expressions.Expression{System.Func{``1,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``1,``4}},System.String)">
            <summary>
            Bind a command from the ViewModel to an explicitly specified control
            on the View.
            </summary>
            <returns>A class representing the binding. Dispose it to disconnect
            the binding</returns>
            <param name="view">The View</param>
            <param name="viewModel">The View model</param>
            <param name="propertyName">The ViewModel command to bind</param>
            <param name="controlName">The name of the control on the view</param>
            <param name="withParameter">The ViewModel property to pass as the
            param of the ICommand</param>
            <param name="toEvent">If specified, bind to the specific event
            instead of the default.</param>
        </member>
        <member name="T:ReactiveUI.CommandBinderImplementation">
            <summary>
            Used by the CommandBinder extension methods to handle binding View controls and ViewModel commands
            </summary>
        </member>
        <member name="M:ReactiveUI.CommandBinderImplementation.BindCommand``5(``1,``0,System.Linq.Expressions.Expression{System.Func{``1,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Func{``4},System.String)">
            <summary>
            Bind a command from the ViewModel to an explicitly specified control
            on the View.
            </summary>
            <returns>A class representing the binding. Dispose it to disconnect
            the binding</returns>
            <param name="view">The View</param>
            <param name="viewModel">The View model</param>
            <param name="controlProperty">The name of the control on the view</param>
            <param name="vmProperty">The ViewModel command to bind</param>
            <param name="withParameter">The ViewModel property to pass as the
            param of the ICommand</param>
            <param name="toEvent">If specified, bind to the specific event
            instead of the default.</param>
        </member>
        <member name="M:ReactiveUI.CommandBinderImplementation.BindCommand``5(``1,``0,System.Linq.Expressions.Expression{System.Func{``1,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.IObservable{``4},System.String)">
            <summary>
            Bind a command from the ViewModel to an explicitly specified control
            on the View.
            </summary>
            <returns>A class representing the binding. Dispose it to disconnect
            the binding</returns>
            <param name="view">The View</param>
            <param name="viewModel">The View model</param>
            <param name="controlProperty">The name of the control on the view</param>
            <param name="vmProperty">The ViewModel command to bind</param>
            <param name="withParameter">The ViewModel property to pass as the
            param of the ICommand</param>
            <param name="toEvent">If specified, bind to the specific event
            instead of the default.</param>
        </member>
        <member name="T:ReactiveUI.InteractionContext`2">
            <summary>
            Contains contextual information for an interaction.
            </summary>
            <remarks>
            <para>
            Instances of this class are passed into interaction handlers. The <see cref="P:ReactiveUI.InteractionContext`2.Input"/> property exposes
            the input to the interaction, whilst the <see cref="M:ReactiveUI.InteractionContext`2.SetOutput(`1)"/> method allows a handler to provide the
            output.
            </para>
            </remarks>
            <typeparam name="TInput">
            The type of the interaction's input.
            </typeparam>
            <typeparam name="TOutput">
            The type of the interaction's output.
            </typeparam>
        </member>
        <member name="P:ReactiveUI.InteractionContext`2.Input">
            <summary>
            Gets the input for the interaction.
            </summary>
        </member>
        <member name="P:ReactiveUI.InteractionContext`2.IsHandled">
            <summary>
            Gets a value indicating whether the interaction is handled. That is, whether the output has been set.
            </summary>
        </member>
        <member name="M:ReactiveUI.InteractionContext`2.SetOutput(`1)">
            <summary>
            Sets the output for the interaction.
            </summary>
            <param name="output">
            The output.
            </param>
            <exception cref="T:System.InvalidOperationException">
            If the output has already been set.
            </exception>
        </member>
        <member name="M:ReactiveUI.InteractionContext`2.GetOutput">
            <summary>
            Gets the output of the interaction.
            </summary>
            <returns>
            The output.
            </returns>
            <exception cref="T:System.InvalidOperationException">
            If the output has not been set.
            </exception>
        </member>
        <member name="T:ReactiveUI.Interaction`2">
            <summary>
            Represents an interaction between collaborating parties.
            </summary>
            <remarks>
            <para>
            Interactions allow collaborating components to asynchronously ask questions of each other. Typically,
            a view model wants to ask the user a question before proceeding with some operation, and it's the view
            that provides the interface via which users can answer the question.
            </para>
            <para>
            Interactions have both an input and output, both of which are strongly-typed via generic type parameters.
            The input is passed into the interaction so that handlers have the information they require. The output
            is provided by a handler.
            </para>
            <para>
            By default, handlers are invoked in reverse order of registration. That is, handlers registered later
            are given the opportunity to handle interactions before handlers that were registered earlier. This
            chaining mechanism enables handlers to be registered temporarily in a specific context, such that
            interactions can be handled in a different manner. Subclasses may modify this behavior by overriding
            the <see cref="M:ReactiveUI.Interaction`2.Handle(`0)"/> method.
            </para>
            <para>
            Note that handlers are not required to handle an interaction. They can choose to ignore it, leaving it
            for some other handler to handle. If no handler handles the interaction, the <see cref="M:ReactiveUI.Interaction`2.Handle(`0)"/> method
            will throw an <see cref="T:ReactiveUI.UnhandledInteractionException`2"/>.
            </para>
            </remarks>
            <typeparam name="TInput">
            The interaction's input type.
            </typeparam>
            <typeparam name="TOutput">
            The interaction's output type.
            </typeparam>
        </member>
        <member name="M:ReactiveUI.Interaction`2.#ctor(System.Reactive.Concurrency.IScheduler)">
            <summary>
            Creates a new interaction instance.
            </summary>
            <param name="handlerScheduler">
            The scheduler to use when invoking handlers, which defaults to <c>CurrentThreadScheduler.Instance</c> if <see langword="null"/>.
            </param>
        </member>
        <member name="M:ReactiveUI.Interaction`2.RegisterHandler(System.Action{ReactiveUI.InteractionContext{`0,`1}})">
            <summary>
            Registers a synchronous interaction handler.
            </summary>
            <remarks>
            <para>
            This overload of <c>RegisterHandler</c> is only useful if the handler can handle the interaction
            immediately. That is, it does not need to wait for a user or some other collaborating component.
            </para>
            </remarks>
            <param name="handler">
            The handler.
            </param>
            <returns>
            A disposable which, when disposed, will unregister the handler.
            </returns>
        </member>
        <member name="M:ReactiveUI.Interaction`2.RegisterHandler(System.Func{ReactiveUI.InteractionContext{`0,`1},System.Threading.Tasks.Task})">
            <summary>
            Registers a task-based asynchronous interaction handler.
            </summary>
            <remarks>
            <para>
            This overload of <c>RegisterHandler</c> is useful if the handler needs to perform some asynchronous
            operation, such as displaying a dialog and waiting for the user's response.
            </para>
            </remarks>
            <param name="handler">
            The handler.
            </param>
            <returns>
            A disposable which, when disposed, will unregister the handler.
            </returns>
        </member>
        <member name="M:ReactiveUI.Interaction`2.RegisterHandler``1(System.Func{ReactiveUI.InteractionContext{`0,`1},System.IObservable{``0}})">
            <summary>
            Registers an observable-based asynchronous interaction handler.
            </summary>
            <remarks>
            <para>
            This overload of <c>RegisterHandler</c> is useful if the handler needs to perform some asynchronous
            operation, such as displaying a dialog and waiting for the user's response.
            </para>
            </remarks>
            <param name="handler">
            The handler.
            </param>
            <returns>
            A disposable which, when disposed, will unregister the handler.
            </returns>
        </member>
        <member name="M:ReactiveUI.Interaction`2.Handle(`0)">
            <summary>
            Handles an interaction and asynchronously returns the result.
            </summary>
            <remarks>
            <para>
            This method passes the interaction through to relevant handlers in reverse order of registration,
            ceasing once any handler handles the interaction. If the interaction remains unhandled after all
            relevant handlers have executed, an <see cref="T:ReactiveUI.UnhandledInteractionException`2"/> is thrown.
            </para>
            </remarks>
            <param name="input">
            The input for the interaction.
            </param>
            <returns>
            An observable that ticks when the interaction completes, or throws an
            <see cref="T:ReactiveUI.UnhandledInteractionException`2"/> if no handler handles the interaction.
            </returns>
        </member>
        <member name="M:ReactiveUI.Interaction`2.GetHandlers">
            <summary>
            Gets all registered handlers in order of their registration.
            </summary>
            <returns>
            All registered handlers.
            </returns>
        </member>
        <member name="T:ReactiveUI.UnhandledInteractionException`2">
            <summary>
            Indicates that an interaction has gone unhandled.
            </summary>
            <typeparam name="TInput">
            The type of the interaction's input.
            </typeparam>
            <typeparam name="TOutput">
            The type of the interaction's output.
            </typeparam>
        </member>
        <member name="P:ReactiveUI.UnhandledInteractionException`2.Interaction">
            <summary>
            Gets the interaction that was not handled.
            </summary>
        </member>
        <member name="P:ReactiveUI.UnhandledInteractionException`2.Input">
            <summary>
            Gets the input for the interaction that was not handled.
            </summary>
        </member>
        <member name="M:ReactiveUI.DependencyResolverMixins.InitializeReactiveUI(Splat.IMutableDependencyResolver)">
            <summary>
            This method allows you to initialize resolvers with the default 
            ReactiveUI types. All resolvers used as the default 
            Locator.Current
            </summary>
            <param name="resolver">The resolver to initialize.</param>
        </member>
        <member name="T:ReactiveUI.INPCObservableForProperty">
            <summary>
            Generates Observables based on observing INotifyPropertyChanged objects
            </summary>
        </member>
        <member name="T:ReactiveUI.IObservedChange`2">
            <summary>
            IObservedChange is a generic interface that is returned from WhenAny()
            Note that it is used for both Changing (i.e.'before change')
            and Changed Observables.
            </summary>
        </member>
        <member name="P:ReactiveUI.IObservedChange`2.Sender">
            <summary>
            The object that has raised the change.
            </summary>
        </member>
        <member name="P:ReactiveUI.IObservedChange`2.Expression">
            <summary>
            The expression of the member that has changed on Sender.
            </summary>
        </member>
        <member name="P:ReactiveUI.IObservedChange`2.Value">
            <summary>
            The value of the property that has changed. IMPORTANT NOTE: This
            property is often not set for performance reasons, unless you have
            explicitly requested an Observable for a property via a method such
            as ObservableForProperty. To retrieve the value for the property,
            use the GetValue() extension method.
            </summary>
        </member>
        <member name="T:ReactiveUI.ObservedChange`2">
            <summary>
            A data-only version of IObservedChange
            </summary>
        </member>
        <member name="M:ReactiveUI.ObservedChange`2.#ctor(`0,System.Linq.Expressions.Expression,`1)">
            <summary>
            Initializes a new instance of the <see cref="T:ReactiveUI.ObservedChange`2"/> class.
            </summary>
            <param name="sender">The sender.</param>
            <param name="expression">Expression describing the member.</param>
            <param name="value">The value.</param>
        </member>
        <member name="P:ReactiveUI.ObservedChange`2.Sender">
             <summary>
            
             </summary>
        </member>
        <member name="P:ReactiveUI.ObservedChange`2.Expression">
             <summary>
            
             </summary>
        </member>
        <member name="P:ReactiveUI.ObservedChange`2.Value">
             <summary>
            
             </summary>
        </member>
        <member name="T:ReactiveUI.IHandleObservableErrors">
             <summary>
             This interface is implemented by RxUI objects which are given
             IObservables as input - when the input IObservables OnError, instead of
             disabling the RxUI object, we catch the IObservable and pipe it into
             this property.
            
             Normally this IObservable is implemented with a ScheduledSubject whose
             default Observer is RxApp.DefaultExceptionHandler - this means, that if
             you aren't listening to ThrownExceptions and one appears, the exception
             will appear on the UI thread and crash the application.
             </summary>
        </member>
        <member name="P:ReactiveUI.IHandleObservableErrors.ThrownExceptions">
            <summary>
            Fires whenever an exception would normally terminate ReactiveUI
            internal state.
            </summary>
        </member>
        <member name="T:ReactiveUI.IReactivePropertyChangedEventArgs`1">
            <summary>
            IReactivePropertyChangedEventArgs is a generic interface that
            is used to wrap the NotifyPropertyChangedEventArgs and gives
            information about changed properties. It includes also
            the sender of the notification.
            Note that it is used for both Changing (i.e.'before change')
            and Changed Observables.
            </summary>
        </member>
        <member name="P:ReactiveUI.IReactivePropertyChangedEventArgs`1.PropertyName">
            <summary>
            The name of the property that has changed on Sender.
            </summary>
        </member>
        <member name="P:ReactiveUI.IReactivePropertyChangedEventArgs`1.Sender">
            <summary>
            The object that has raised the change.
            </summary>
        </member>
        <member name="T:ReactiveUI.ReactivePropertyChangingEventArgs`1">
             <summary>
            
             </summary>
             <typeparam name="TSender"></typeparam>
        </member>
        <member name="M:ReactiveUI.ReactivePropertyChangingEventArgs`1.#ctor(`0,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:ReactiveUI.ReactivePropertyChangingEventArgs`1"/> class.
            </summary>
            <param name="sender">The sender.</param>
            <param name="propertyName">Name of the property.</param>
        </member>
        <member name="P:ReactiveUI.ReactivePropertyChangingEventArgs`1.Sender">
             <summary>
            
             </summary>
        </member>
        <member name="T:ReactiveUI.ReactivePropertyChangedEventArgs`1">
             <summary>
            
             </summary>
             <typeparam name="TSender"></typeparam>
        </member>
        <member name="M:ReactiveUI.ReactivePropertyChangedEventArgs`1.#ctor(`0,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:ReactiveUI.ReactivePropertyChangedEventArgs`1"/> class.
            </summary>
            <param name="sender">The sender.</param>
            <param name="propertyName">Name of the property.</param>
        </member>
        <member name="P:ReactiveUI.ReactivePropertyChangedEventArgs`1.Sender">
             <summary>
            
             </summary>
        </member>
        <member name="T:ReactiveUI.IReactiveNotifyPropertyChanged`1">
            <summary>
            IReactiveNotifyPropertyChanged represents an extended version of
            INotifyPropertyChanged that also exposes typed Observables.
            </summary>
        </member>
        <member name="P:ReactiveUI.IReactiveNotifyPropertyChanged`1.Changing">
            <summary>
            Represents an Observable that fires *before* a property is about to
            be changed. Note that this should not fire duplicate change notifications if a
            property is set to the same value multiple times.
            </summary>
        </member>
        <member name="P:ReactiveUI.IReactiveNotifyPropertyChanged`1.Changed">
            <summary>
            Represents an Observable that fires *after* a property has changed.
            Note that this should not fire duplicate change notifications if a
            property is set to the same value multiple times.
            </summary>
        </member>
        <member name="M:ReactiveUI.IReactiveNotifyPropertyChanged`1.SuppressChangeNotifications">
            <summary>
            When this method is called, an object will not fire change
            notifications (neither traditional nor Observable notifications)
            until the return value is disposed.
            </summary>
            <returns>An object that, when disposed, reenables change
            notifications.</returns>
        </member>
        <member name="T:ReactiveUI.IReactiveNotifyCollectionItemChanged`1">
            <summary>
            IReactiveNotifyCollectionItemChanged provides notifications for collection item updates, ie when an object in
            a collection changes.
            </summary>
        </member>
        <member name="P:ReactiveUI.IReactiveNotifyCollectionItemChanged`1.ItemChanging">
            <summary>
            Provides Item Changing notifications for any item in collection that
            implements IReactiveNotifyPropertyChanged. This is only enabled when
            ChangeTrackingEnabled is set to True.
            </summary>
        </member>
        <member name="P:ReactiveUI.IReactiveNotifyCollectionItemChanged`1.ItemChanged">
            <summary>
            Provides Item Changed notifications for any item in collection that
            implements IReactiveNotifyPropertyChanged. This is only enabled when
            ChangeTrackingEnabled is set to True.
            </summary>
        </member>
        <member name="P:ReactiveUI.IReactiveNotifyCollectionItemChanged`1.ChangeTrackingEnabled">
            <summary>
            Enables the ItemChanging and ItemChanged properties; when this is
            enabled, whenever a property on any object implementing
            IReactiveNotifyPropertyChanged changes, the change will be
            rebroadcast through ItemChanging/ItemChanged.
            </summary>
        </member>
        <member name="T:ReactiveUI.IReactiveNotifyCollectionChanged`1">
            <summary>
            IReactiveNotifyCollectionChanged of T provides notifications when the contents
            of collection are changed (items are added/removed/moved).
            </summary>
        </member>
        <member name="P:ReactiveUI.IReactiveNotifyCollectionChanged`1.ItemsAdded">
            <summary>
            Fires when items are added to the collection, once per item added.
            Functions that add multiple items such AddRange should fire this
            multiple times. The object provided is the item that was added.
            </summary>
        </member>
        <member name="P:ReactiveUI.IReactiveNotifyCollectionChanged`1.BeforeItemsAdded">
            <summary>
            Fires before an item is going to be added to the collection.
            </summary>
        </member>
        <member name="P:ReactiveUI.IReactiveNotifyCollectionChanged`1.ItemsRemoved">
            <summary>
            Fires once an item has been removed from a collection, providing the
            item that was removed.
            </summary>
        </member>
        <member name="P:ReactiveUI.IReactiveNotifyCollectionChanged`1.BeforeItemsRemoved">
            <summary>
            Fires before an item will be removed from a collection, providing
            the item that will be removed.
            </summary>
        </member>
        <member name="P:ReactiveUI.IReactiveNotifyCollectionChanged`1.BeforeItemsMoved">
            <summary>
            Fires before an items moves from one position in the collection to
            another, providing the item(s) to be moved as well as source and destination
            indices.
            </summary>
        </member>
        <member name="P:ReactiveUI.IReactiveNotifyCollectionChanged`1.ItemsMoved">
            <summary>
            Fires once one or more items moves from one position in the collection to
            another, providing the item(s) that was moved as well as source and destination
            indices.
            </summary>
        </member>
        <member name="P:ReactiveUI.IReactiveNotifyCollectionChanged`1.Changing">
            <summary>
            This Observable is equivalent to the NotifyCollectionChanged event,
            but fires before the collection is changed
            </summary>
        </member>
        <member name="P:ReactiveUI.IReactiveNotifyCollectionChanged`1.Changed">
            <summary>
            This Observable is equivalent to the NotifyCollectionChanged event,
            and fires after the collection is changed
            </summary>
        </member>
        <member name="P:ReactiveUI.IReactiveNotifyCollectionChanged`1.CountChanging">
            <summary>
            Fires when the collection count changes, regardless of reason
            </summary>
        </member>
        <member name="P:ReactiveUI.IReactiveNotifyCollectionChanged`1.CountChanged">
            <summary>
            Fires when the collection count changes, regardless of reason
            </summary>
        </member>
        <member name="P:ReactiveUI.IReactiveNotifyCollectionChanged`1.ShouldReset">
             <summary>
             This Observable is fired when a ShouldReset fires on the collection. This
             means that you should forget your previous knowledge of the state
             of the collection and reread it.
            
             This does *not* mean Clear, and if you interpret it as such, you are
             Doing It Wrong.
             </summary>
        </member>
        <member name="T:ReactiveUI.IReactiveCollection`1">
             IReactiveCollection of T represents a collection that can notify when its
             contents are changed (either items are added/removed, or the object
             itself changes).
            
             It is important to implement the Changing/Changed from
             IReactiveNotifyPropertyChanged semantically as "Fire when *anything* in
             the collection or any of its items have changed, in any way".
        </member>
        <member name="M:ReactiveUI.IReactiveCollection`1.Reset">
             <summary>
            
             </summary>
        </member>
        <member name="T:ReactiveUI.IReadOnlyReactiveCollection`1">
             <summary>
             IReadOnlyReactiveCollection of T represents a read-only collection that can notify when its
             contents are changed (either items are added/removed, or the object
             itself changes).
            
             It is important to implement the Changing/Changed from
             IReactiveNotifyPropertyChanged semantically as "Fire when *anything* in
             the collection or any of its items have changed, in any way".
             </summary>
        </member>
        <member name="T:ReactiveUI.IReadOnlyReactiveList`1">
             <summary>
             IReadOnlyReactiveList of T represents a read-only list that can notify when its
             contents are changed (either items are added/removed, or the object
             itself changes).
            
             It is important to implement the Changing/Changed from
             IReactiveNotifyPropertyChanged semantically as "Fire when *anything* in
             the collection or any of its items have changed, in any way".
             </summary>
        </member>
        <member name="T:ReactiveUI.IReactiveDerivedList`1">
            <summary>
            IReactiveDerivedList represents a collection whose contents will "follow" another
            collection; this method is useful for creating ViewModel collections
            that are automatically updated when the respective Model collection is updated.
            </summary>
        </member>
        <member name="T:ReactiveUI.IReactiveList`1">
             <summary>
             IReactiveList of T represents a list that can notify when its
             contents are changed (either items are added/removed, or the object
             itself changes).
            
             It is important to implement the Changing/Changed from
             IReactiveNotifyPropertyChanged semantically as "Fire when *anything* in
             the collection or any of its items have changed, in any way".
             </summary>
        </member>
        <member name="T:ReactiveUI.IRoutableViewModel">
            <summary>
            Implement this interface for ViewModels that can be navigated to.
            </summary>
        </member>
        <member name="P:ReactiveUI.IRoutableViewModel.UrlPathSegment">
            <summary>
            A string token representing the current ViewModel, such as 'login' or 'user'
            </summary>
        </member>
        <member name="P:ReactiveUI.IRoutableViewModel.HostScreen">
            <summary>
            The IScreen that this ViewModel is currently being shown in. This
            is usually passed into the ViewModel in the Constructor and saved
            as a ReadOnly Property.
            </summary>
        </member>
        <member name="T:ReactiveUI.ISupportsActivation">
            <summary>
            Implementing this interface on a ViewModel indicates that the ViewModel
            is interested in Activation events. Instantiate the Activator, then call
            WhenActivated on your class to register what you want to happen when
            the View is activated. See the documentation for ViewModelActivator to
            read more about Activation.
            </summary>
        </member>
        <member name="T:ReactiveUI.ICanActivate">
            <summary>
            This Interface is used by the framework to explicitly provide activation
            events. Usually you can ignore this unless you are porting RxUI to a new
            UI Toolkit.
            </summary>
        </member>
        <member name="T:ReactiveUI.IROObservableForProperty">
            <summary>
            Generates Observables based on observing Reactive objects
            </summary>
        </member>
        <member name="T:ReactiveUI.MessageBus">
             <summary>
             MessageBus represents an object that can act as a "Message Bus", a
             simple way for ViewModels and other objects to communicate with each
             other in a loosely coupled way.
            
             Specifying which messages go where is done via a combination of the Type
             of the message as well as an additional "Contract" parameter; this is a
             unique string used to distinguish between messages of the same Type, and
             is arbitrarily set by the client. 
             </summary>
        </member>
        <member name="P:ReactiveUI.MessageBus.Current">
            <summary>
            Gets or sets the Current MessageBus.
            </summary>
        </member>
        <member name="M:ReactiveUI.MessageBus.RegisterScheduler``1(System.Reactive.Concurrency.IScheduler,System.String)">
            <summary>
            Registers a scheduler for the type, which may be specified at runtime, and the contract.
            </summary>
            <remarks>If a scheduler is already registered for the specified runtime and contract, this will overrwrite the existing registration.</remarks>
            <typeparam name="T">The type of the message to listen to.</typeparam>
            <param name="scheduler">The scheduler on which to post the
            notifications for the specified type and contract. CurrentThreadScheduler by default.</param>
            <param name="contract">A unique string to distinguish messages with
            identical types (i.e. "MyCoolViewModel") - if the message type is
            only used for one purpose, leave this as null.</param>
        </member>
        <member name="M:ReactiveUI.MessageBus.Listen``1(System.String)">
            <summary>
            Listen provides an Observable that will fire whenever a Message is
            provided for this object via RegisterMessageSource or SendMessage.
            </summary>
            <typeparam name="T">The type of the message to listen to.</typeparam>
            <param name="contract">A unique string to distinguish messages with
            identical types (i.e. "MyCoolViewModel") - if the message type is
            only used for one purpose, leave this as null.</param>
            <returns>An Observable representing the notifications posted to the
            message bus.</returns>
        </member>
        <member name="M:ReactiveUI.MessageBus.ListenIncludeLatest``1(System.String)">
            <summary>
            Listen provides an Observable that will fire whenever a Message is
            provided for this object via RegisterMessageSource or SendMessage.
            </summary>
            <typeparam name="T">The type of the message to listen to.</typeparam>
            <param name="contract">A unique string to distinguish messages with
            identical types (i.e. "MyCoolViewModel") - if the message type is
            only used for one purpose, leave this as null.</param>
            <returns>An Observable representing the notifications posted to the
            message bus.</returns>
        </member>
        <member name="M:ReactiveUI.MessageBus.IsRegistered(System.Type,System.String)">
            <summary>
            Determines if a particular message Type is registered.
            </summary>
            <param name="type">The Type of the message to listen to.</param>
            <param name="contract">A unique string to distinguish messages with
            identical types (i.e. "MyCoolViewModel") - if the message type is
            only used for one purpose, leave this as null.</param>
            <returns>True if messages have been posted for this message Type.</returns>
        </member>
        <member name="M:ReactiveUI.MessageBus.RegisterMessageSource``1(System.IObservable{``0},System.String)">
            <summary>
            Registers an Observable representing the stream of messages to send.
            Another part of the code can then call Listen to retrieve this
            Observable.
            </summary>
            <typeparam name="T">The type of the message to listen to.</typeparam>
            <param name="source">An Observable that will be subscribed to, and a
            message sent out for each value provided.</param>
            <param name="contract">A unique string to distinguish messages with
            identical types (i.e. "MyCoolViewModel") - if the message type is
            only used for one purpose, leave this as null.</param>
        </member>
        <member name="M:ReactiveUI.MessageBus.SendMessage``1(``0,System.String)">
            <summary>
            Sends a single message using the specified Type and contract.
            Consider using RegisterMessageSource instead if you will be sending
            messages in response to other changes such as property changes
            or events.
            </summary>
            <typeparam name="T">The type of the message to send.</typeparam>
            <param name="message">The actual message to send</param>
            <param name="contract">A unique string to distinguish messages with
            identical types (i.e. "MyCoolViewModel") - if the message type is
            only used for one purpose, leave this as null.</param>
        </member>
        <member name="P:ReactiveUI.SuspensionHost.CreateNewAppState">
             <summary>
            
             </summary>
        </member>
        <member name="P:ReactiveUI.SuspensionHost.AppState">
             <summary>
            
             </summary>
        </member>
        <member name="M:ReactiveUI.SuspensionHostExtensions.ObserveAppState``1(ReactiveUI.ISuspensionHost)">
             <summary>
            
             </summary>
             <typeparam name="T"></typeparam>
             <param name="This"></param>
             <returns></returns>
        </member>
        <member name="M:ReactiveUI.SuspensionHostExtensions.GetAppState``1(ReactiveUI.ISuspensionHost)">
             <summary>
            
             </summary>
             <typeparam name="T"></typeparam>
             <param name="This"></param>
             <returns></returns>
        </member>
        <member name="M:ReactiveUI.SuspensionHostExtensions.SetupDefaultSuspendResume(ReactiveUI.ISuspensionHost,ReactiveUI.ISuspensionDriver)">
             <summary>
            
             </summary>
             <param name="This"></param>
             <param name="driver"></param>
             <returns></returns>
        </member>
        <member name="T:ReactiveUI.DummySuspensionDriver">
             <summary>
            
             </summary>
        </member>
        <member name="T:ReactiveUI.ObservableAsPropertyHelper`1">
            <summary>
            ObservableAsPropertyHelper is a class to help ViewModels implement
            "output properties", that is, a property that is backed by an
            Observable. The property will be read-only, but will still fire change
            notifications. This class can be created directly, but is more often created 
            via the <see cref="T:ReactiveUI.OAPHCreationHelperMixin" /> extension methods.    
            </summary>
        </member>
        <member name="M:ReactiveUI.ObservableAsPropertyHelper`1.#ctor(System.IObservable{`0},System.Action{`0},`0,System.Boolean,System.Reactive.Concurrency.IScheduler)">
            <summary>
            Constructs an ObservableAsPropertyHelper object.
            </summary>
            <param name="observable">
            The Observable to base the property on.
            </param>
            <param name="onChanged">
            The action to take when the property changes, typically this will call the 
            ViewModel's RaisePropertyChanged method.
            </param>
            <param name="initialValue">
            The initial value of the property.
            </param>
            <param name="deferSubscription">
            A value indicating whether the <see cref="T:ReactiveUI.ObservableAsPropertyHelper`1"/> 
            should defer the subscription to the <paramref name="observable"/> source 
            until the first call to <see cref="P:ReactiveUI.ObservableAsPropertyHelper`1.Value"/>, or if it should immediately 
            subscribe to the the <paramref name="observable"/> source.
            </param>
            <param name="scheduler">
            The scheduler that the notifications will be provided on - 
            this should normally be a Dispatcher-based scheduler
            </param>
        </member>
        <member name="M:ReactiveUI.ObservableAsPropertyHelper`1.#ctor(System.IObservable{`0},System.Action{`0},System.Action{`0},`0,System.Boolean,System.Reactive.Concurrency.IScheduler)">
            <summary>
            Constructs an ObservableAsPropertyHelper object.
            </summary>
            <param name="observable">
            The Observable to base the property on.
            </param>
            <param name="onChanged">
            The action to take when the property changes, typically this will call 
            the ViewModel's RaisePropertyChanged method.
            </param>
            <param name="onChanging">
            The action to take when the property changes, typically this will call 
            the ViewModel's RaisePropertyChanging method.
            </param>
            <param name="initialValue">
            The initial value of the property.
            </param>
            <param name="deferSubscription">
            A value indicating whether the <see cref="T:ReactiveUI.ObservableAsPropertyHelper`1"/> 
            should defer the subscription to the <paramref name="observable"/> source 
            until the first call to <see cref="P:ReactiveUI.ObservableAsPropertyHelper`1.Value"/>, or if it should immediately 
            subscribe to the the <paramref name="observable"/> source.
            </param>
            <param name="scheduler">
            The scheduler that the notifications will provided on - this 
            should normally be a Dispatcher-based scheduler
            </param>
        </member>
        <member name="P:ReactiveUI.ObservableAsPropertyHelper`1.Value">
            <summary>
            The last provided value from the Observable. 
            </summary>
        </member>
        <member name="P:ReactiveUI.ObservableAsPropertyHelper`1.ThrownExceptions">
            <summary>
            Fires whenever an exception would normally terminate ReactiveUI 
            internal state.
            </summary>
        </member>
        <member name="M:ReactiveUI.ObservableAsPropertyHelper`1.Dispose">
            <summary>
            Disposes this ObservableAsPropertyHelper
            </summary>
        </member>
        <member name="M:ReactiveUI.ObservableAsPropertyHelper`1.Default(`0,System.Reactive.Concurrency.IScheduler)">
            <summary>
            Constructs a "default" ObservableAsPropertyHelper object. This is
            useful for when you will initialize the OAPH later, but don't want
            bindings to access a null OAPH at startup.
            </summary>
            <param name="initialValue">
            The initial (and only) value of the property.
            </param>
            <param name="scheduler">
            The scheduler that the notifications will be provided on - this should 
            normally be a Dispatcher-based scheduler
            </param>
        </member>
        <member name="T:ReactiveUI.OAPHCreationHelperMixin">
            <summary>
            A collection of helpers to aid working with observable properties
            </summary>
        </member>
        <member name="M:ReactiveUI.OAPHCreationHelperMixin.ToProperty``2(System.IObservable{``1},``0,System.Linq.Expressions.Expression{System.Func{``0,``1}},``1,System.Boolean,System.Reactive.Concurrency.IScheduler)">
            <summary>
            Converts an Observable to an ObservableAsPropertyHelper and
            automatically provides the onChanged method to raise the property
            changed notification.         
            </summary>
            <param name="This">
            The observable to convert to an ObservableAsPropertyHelper
            </param>
            <param name="source">
            The ReactiveObject that has the property
            </param>
            <param name="property">
            An Expression representing the property (i.e. <c>x => x.SomeProperty</c>)
            </param>
            <param name="initialValue">
            The initial value of the property.
            </param>
            <param name="deferSubscription">
            A value indicating whether the <see cref="T:ReactiveUI.ObservableAsPropertyHelper`1"/> 
            should defer the subscription to the <paramref name="This"/> source 
            until the first call to <see cref="P:ReactiveUI.ObservableAsPropertyHelper`1.Value"/>,
            or if it should immediately subscribe to the the <paramref name="This"/> source.
            </param>
            <param name="scheduler">
            The scheduler that the notifications will be provided on - this should normally 
            be a Dispatcher-based scheduler
            </param>
            <returns>
            An initialized ObservableAsPropertyHelper; use this as the backing field 
            for your property.
            </returns>
        </member>
        <member name="M:ReactiveUI.OAPHCreationHelperMixin.ToProperty``2(System.IObservable{``1},``0,System.Linq.Expressions.Expression{System.Func{``0,``1}},ReactiveUI.ObservableAsPropertyHelper{``1}@,``1,System.Boolean,System.Reactive.Concurrency.IScheduler)">
            <summary>
            Converts an Observable to an ObservableAsPropertyHelper and
            automatically provides the onChanged method to raise the property
            changed notification.         
            </summary>
            <param name="This">
            The observable to convert to an ObservableAsPropertyHelper
            </param>
            <param name="source">
            The ReactiveObject that has the property
            </param>
            <param name="property">
            An Expression representing the property (i.e. <c>x => x.SomeProperty</c>)
            </param>
            <param name="result">
            An out param matching the return value, provided for convenience
            </param>
            <param name="initialValue">
            The initial value of the property.
            </param>
            <param name="deferSubscription">
            A value indicating whether the <see cref="T:ReactiveUI.ObservableAsPropertyHelper`1"/> 
            should defer the subscription to the <paramref name="This"/> source 
            until the first call to <see cref="P:ReactiveUI.ObservableAsPropertyHelper`1.Value"/>, 
            or if it should immediately subscribe to the the <paramref name="This"/> source.
            </param>
            <param name="scheduler">
            The scheduler that the notifications will be provided on - this should 
            normally be a Dispatcher-based scheduler
            </param>
            <returns>
            An initialized ObservableAsPropertyHelper; use this as the backing 
            field for your property.
            </returns>
        </member>
        <member name="T:ReactiveUI.ObservedChangedMixin">
            <summary>
            A collection of helpers for <see cref="T:ReactiveUI.IObservedChange`2"/>.
            </summary>
        </member>
        <member name="M:ReactiveUI.ObservedChangedMixin.GetPropertyName``2(ReactiveUI.IObservedChange{``0,``1})">
            <summary>
            Returns the name of a property which has been changed.
            </summary>
            <returns>
            The name of the property which has changed.
            </returns>
        </member>
        <member name="M:ReactiveUI.ObservedChangedMixin.GetValue``2(ReactiveUI.IObservedChange{``0,``1})">
            <summary>
            Returns the current value of a property given a notification that
            it has changed.
            </summary>
            <param name="This">
            The <see cref="T:ReactiveUI.IObservedChange`2"/> instance to get the value of.
            </param>
            <returns>
            The current value of the property
            </returns>
        </member>
        <member name="M:ReactiveUI.ObservedChangedMixin.TryGetValue``2(ReactiveUI.IObservedChange{``0,``1},``1@)">
            <summary>
            Attempts to return the current value of a property given a 
            notification that it has changed. If any property in the
            property expression is null, false is returned.
            </summary>
            <param name="This">
            The <see cref="T:ReactiveUI.IObservedChange`2"/> instance to get the value of
            </param>
            <param name="changeValue">
            The value of the property expression.
            </param>
            <returns>
            True if the entire expression was able to be followed, false otherwise.
            </returns>
        </member>
        <member name="M:ReactiveUI.ObservedChangedMixin.SetValueToProperty``3(ReactiveUI.IObservedChange{``0,``1},``2,System.Linq.Expressions.Expression{System.Func{``2,``1}})">
            <summary>
            Given a fully filled-out IObservedChange object, SetValueToProperty
            will apply it to the specified object (i.e. it will ensure that
            target.property == This.GetValue() and "replay" the observed change
            onto another object).
            </summary>
            <param name="This">
            The <see cref="T:ReactiveUI.IObservedChange`2"/> instance to use as a 
            value to apply.
            </param>
            <param name="target">
            The target object to apply the change to.
            </param>
            <param name="property">
            The target property to apply the change to.
            </param>
        </member>
        <member name="M:ReactiveUI.ObservedChangedMixin.Value``2(System.IObservable{ReactiveUI.IObservedChange{``0,``1}})">
            <summary>
            Given a stream of notification changes, this method will convert 
            the property changes to the current value of the property.
            </summary>
            <param name="This">
            The change notification stream to get the values of.
            </param>
            <returns>
            An Observable representing the stream of current values of
            the given change notification stream.
            </returns>
        </member>
        <member name="T:ReactiveUI.IComparerBuilder`1">
            <summary>
            Convienience interface for providing a starting point for chaining comparers.
            </summary>
        </member>
        <member name="M:ReactiveUI.IComparerBuilder`1.OrderBy``1(System.Func{`0,``0})">
            <summary>
            Creates a derived comparer based on the given parent comparer. The returned comparer will sort elements
            using the parent comparer first. If the parent considers the values equal elements will be sorted
            in ascending order based on the values returned by the provided selector. The selector values will be
            compared using the default comparer for the return type of the selector.
            </summary>
            <param name="selector">
            A function supplying the values for the comparer.
            </param>
        </member>
        <member name="M:ReactiveUI.IComparerBuilder`1.OrderBy``1(System.Func{`0,``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Creates a derived comparer based on the given parent comparer. The returned comparer will sort elements
            using the parent comparer first. If the parent considers the values equal elements will be sorted
            in ascending order based on the values returned by the provided selector. The selector values will be
            compared using the provided comparer or the default comparer for the return type of the selector if no
            comparer is specified.
            </summary>
            <param name="selector">
            A function supplying the values for the comparer.
            </param>
            <param name="comparer">
            The comparer to use when comparing the values returned by the selector. 
            The default comparer for that type will be used if this parameter is null.
            </param>
        </member>
        <member name="M:ReactiveUI.IComparerBuilder`1.OrderByDescending``1(System.Func{`0,``0})">
            <summary>
            Creates a derived comparer based on the given parent comparer. The returned comparer will sort elements
            using the parent comparer first. If the parent considers the values equal elements will be sorted
            in descending order based on the values returned by the provided selector. The selector values will be
            compared using the default comparer for the return type of the selector.
            </summary>
            <param name="selector">
            A function supplying the values for the comparer.
            </param>
        </member>
        <member name="M:ReactiveUI.IComparerBuilder`1.OrderByDescending``1(System.Func{`0,``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Creates a derived comparer based on the given parent comparer. The returned comparer will sort elements
            using the parent comparer first. If the parent considers the values equal elements will be sorted
            in descending order based on the values returned by the provided selector. The selector values will be
            compared using the provided comparer or the default comparer for the return type of the selector if no
            comparer is specified.
            </summary>
            <param name="selector">
            A function supplying the values for the comparer.
            </param>
            /// <param name="comparer">
            The comparer to use when comparing the values returned by the selector. 
            The default comparer for that type will be used if this parameter is null.
            </param>
        </member>
        <member name="T:ReactiveUI.OrderedComparer">
            <summary>
            Convienience class providing a starting point for chaining comparers for anonymous types.
            </summary>
            <remarks>
            If the type you're creating a comparer for is known this class is nothing more than an alias for the generic
            OrderedComparer. This class can be used to create comparers for anonymous types
            </remarks>
        </member>
        <member name="M:ReactiveUI.OrderedComparer.For``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Creates a type inferred comparer builder for the element type of the enumerable. Useful for creating
            comparers for anonymous types. Note that the builder is not a comparer in itself, you need to use the
            OrderBy or OrderByDescending methods on the builder to get an actual comparer.
            </summary>
        </member>
        <member name="M:ReactiveUI.OrderedComparer.For``1">
            <summary>
            Creates a comparer builder for the specified type. Note that the builder is not a comparer in itself,
            you need to use the OrderBy or OrderByDescending methods on the builder to get an actual comparer.
            If the type is known at compile time this method is nothing more than an alias for the generic
            OrdedComparer class.
            </summary>
        </member>
        <member name="T:ReactiveUI.OrderedComparer`1">
            <summary>
            Convienience class providing a starting point for chaining comparers.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:ReactiveUI.OrderedComparer`1.OrderBy``1(System.Func{`0,``0})">
            <summary>
            Creates a comparer that will sort elements in ascending order based on the values returned by the provided
            selector. The values will be compared using the default comparer for the return type of the selector.
            </summary>
            <param name="selector">
            A function supplying the values for the comparer.
            </param>
        </member>
        <member name="M:ReactiveUI.OrderedComparer`1.OrderBy``1(System.Func{`0,``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Creates a comparer that will sort elements in ascending order based on the values returned by the provided
            selector. The selector values will be compared using the provided comparer or the default comparer for the 
            return type of the selector if no comparer is specified.
            </summary>
            <param name="selector">
            A function supplying the values for the comparer.
            </param>
            <param name="comparer">
            The comparer to use when comparing the values returned by the selector. 
            The default comparer for that type will be used if this parameter is null.
            </param>
        </member>
        <member name="M:ReactiveUI.OrderedComparer`1.OrderByDescending``1(System.Func{`0,``0})">
            <summary>
            Creates a comparer that will sort elements in descending order based on the values returned by the provided
            selector. The values will be compared using the default comparer for the return type of the selector.
            </summary>
            <param name="selector">
            A function supplying the values for the comparer.
            </param>
        </member>
        <member name="M:ReactiveUI.OrderedComparer`1.OrderByDescending``1(System.Func{`0,``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Creates a comparer that will sort elements in descending order based on the values returned by the provided
            selector. The selector values will be compared using the provided comparer or the default comparer for the 
            return type of the selector if no comparer is specified.
            </summary>
            <param name="selector">
            A function supplying the values for the comparer.
            </param>
            <param name="comparer">
            The comparer to use when comparing the values returned by the selector. 
            The default comparer for that type will be used if this parameter is null.
            </param>
        </member>
        <member name="T:ReactiveUI.ComparerChainingExtensions">
            <summary>
            Convenience class to help chain selectors onto existing parent comparers.
            </summary>
        </member>
        <member name="M:ReactiveUI.ComparerChainingExtensions.ThenBy``2(System.Collections.Generic.IComparer{``0},System.Func{``0,``1})">
            <summary>
            Creates a derived comparer based on the given parent comparer. The returned comparer will sort elements 
            using the parent comparer first. If the parent considers the values equal elements will be sorted 
            in ascending order based on the values returned by the provided selector. The selector values will be 
            compared using the default comparer for the return type of the selector.
            </summary>
            <param name="parent">
            The parent comparer to use first.
            </param>
            <param name="selector">
            A function supplying the values for the comparer.
            </param>
        </member>
        <member name="M:ReactiveUI.ComparerChainingExtensions.ThenBy``2(System.Collections.Generic.IComparer{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})">
            <summary>
            Creates a derived comparer based on the given parent comparer. The returned comparer will sort elements 
            using the parent comparer first. If the parent considers the values equal elements will be sorted 
            in ascending order based on the values returned by the provided selector. The selector values will be 
            compared using the provided comparer or the default comparer for the return type of the selector if no 
            comparer is specified.
            </summary>
            <param name="parent">
            The parent comparer to use first.
            </param>
            <param name="selector">
            A function supplying the values for the comparer.
            </param>
            <param name="comparer">
            The comparer to use when comparing the values returned by the selector. 
            </param>
        </member>
        <member name="M:ReactiveUI.ComparerChainingExtensions.ThenByDescending``2(System.Collections.Generic.IComparer{``0},System.Func{``0,``1})">
            <summary>
            Creates a derived comparer based on the given parent comparer. The returned comparer will sort elements 
            using the parent comparer first. If the parent considers the values equal elements will be sorted 
            in descending order based on the values returned by the provided selector. The selector values will be 
            compared using the default comparer for the return type of the selector.
            </summary>
            <param name="parent">
            The parent comparer to use first.
            </param>
            <param name="selector">
            A function supplying the values for the comparer.
            </param>
        </member>
        <member name="M:ReactiveUI.ComparerChainingExtensions.ThenByDescending``2(System.Collections.Generic.IComparer{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})">
            <summary>
            Creates a derived comparer based on the given parent comparer. The returned comparer will sort elements 
            using the parent comparer first. If the parent considers the values equal elements will be sorted 
            in descending order based on the values returned by the provided selector. The selector values will be 
            compared using the provided comparer or the default comparer for the return type of the selector if no 
            comparer is specified.
            </summary>
            <param name="parent">
            The parent comparer to use first.
            </param>
            <param name="selector">
            A function supplying the values for the comparer.
            </param>
            <param name="comparer">
            The comparer to use when comparing the values returned by the selector. 
            </param>
        </member>
        <member name="T:ReactiveUI.POCOObservableForProperty">
            <summary>
            This class is the final fallback for WhenAny, and will simply immediately
            return the value of the type at the time it was created. It will also 
            warn the user that this is probably not what they want to do
            </summary>
        </member>
        <member name="T:ReactiveUI.BindingMixins">
            <summary>
            This class provides extension methods for the ReactiveUI view binding mechanism.
            </summary>
        </member>
        <member name="M:ReactiveUI.BindingMixins.Bind``4(``1,``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``3}},System.Object,ReactiveUI.IBindingTypeConverter,ReactiveUI.IBindingTypeConverter)">
            <summary>
            Binds the specified view model property to the given view property.
            </summary>
            <typeparam name="TViewModel">The type of the view model being bound.</typeparam>
            <typeparam name="TView">The type of the view being bound.</typeparam>
            <typeparam name="TVMProp">The type of the property bound on the view model.</typeparam>
            <typeparam name="TVProp">The type of the property bound on the view.</typeparam>
            <param name="view">The instance of the view to bind.</param>
            <param name="viewModel">The instance of the view model to bind.</param>
            <param name="vmProperty">
            An expression indicating the property that is bound on the view model.
            This can be a chain of properties of the form <code>vm =&gt; vm.Foo.Bar.Baz</code>
            and the binder will attempt to subscribe to changes on each recursively.
            </param>
            <param name="viewProperty">
            The property on the view that is to be bound.
            This can be a chain of properties of the form <code>view => view.Foo.Bar.Baz</code>
            and the binder will attempt to set the last one each time the view model property is updated.
            </param>
            <param name="conversionHint">
            An object that can provide a hint for the converter.
            The semantics of this object is defined by the converter used.
            </param>
            <param name="vmToViewConverterOverride">
            An optional <see cref="T:ReactiveUI.IBindingTypeConverter"/> to use when converting from the 
            viewModel to view property.
            </param>
            <param name="viewToVMConverterOverride">
            An optional <see cref="T:ReactiveUI.IBindingTypeConverter"/> to use when converting from the 
            view to viewModel property.
            </param>
            <returns>
            An instance of <see cref="T:System.IDisposable"/> that, when disposed,
            disconnects the binding.
            </returns>
        </member>
        <member name="M:ReactiveUI.BindingMixins.Bind``5(``1,``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``3}},System.IObservable{``4},System.Object,ReactiveUI.IBindingTypeConverter,ReactiveUI.IBindingTypeConverter)">
            <summary>
            Binds the specified view model property to the given view property, and 
            provide a custom view update signaller to signal when the view property has been updated.
            </summary>
            <typeparam name="TViewModel">The type of the view model being bound.</typeparam>
            <typeparam name="TView">The type of the view being bound.</typeparam>
            <typeparam name="TVMProp">The type of the property bound on the view model.</typeparam>
            <typeparam name="TVProp">The type of the property bound on the view.</typeparam>
            <param name="view">The instance of the view to bind.</param>
            <typeparam name="TDontCare">
            A dummy type, only the fact that <paramref name="signalViewUpdate"/> 
            emits values is considered, not the actual values emitted.
            </typeparam>
            <param name="viewModel">The instance of the view model to bind.</param>
            <param name="vmProperty">
            An expression indicating the property that is bound on the view model.
            This can be a chain of properties of the form <code>vm =&gt; vm.Foo.Bar.Baz</code>
            and the binder will attempt to subscribe to changes on each recursively.
            </param>
            <param name="viewProperty">
            The property on the view that is to be bound.
            This can be a chain of properties of the form <code>view => view.Foo.Bar.Baz</code>
            and the binder will attempt to set the last one each time the view model property is updated.
            </param>
            <param name="signalViewUpdate">
            An observable, that when signaled, indicates that the view property 
            has been changed, and that the binding should update the view model
            property accordingly.
            </param>
            <param name="conversionHint">
            An object that can provide a hint for the converter.
            The semantics of this object is defined by the converter used.
            </param>
            <param name="vmToViewConverterOverride">
            An optional <see cref="T:ReactiveUI.IBindingTypeConverter"/> to use when converting from the 
            viewModel to view property.
            </param>
            <param name="viewToVMConverterOverride">
            An optional <see cref="T:ReactiveUI.IBindingTypeConverter"/> to use when converting from the 
            view to viewModel property.
            </param>
            <returns>
            An instance of <see cref="T:System.IDisposable"/> that, when disposed,
            disconnects the binding.
            </returns>
        </member>
        <member name="M:ReactiveUI.BindingMixins.Bind``4(``1,``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``3}},System.Func{``2,``3},System.Func{``3,``2})">
            <summary>
            Binds the specified view model property to the given view property.
            </summary>
            <typeparam name="TViewModel">The type of the view model being bound.</typeparam>
            <typeparam name="TView">The type of the view being bound.</typeparam>
            <typeparam name="TVMProp">The type of the property bound on the view model.</typeparam>
            <typeparam name="TVProp">The type of the property bound on the view.</typeparam>
            <param name="view">The instance of the view to bind.</param>
            <param name="viewModel">The instance of the view model to bind.</param>
            <param name="vmProperty">
            An expression indicating the property that is bound on the view model.
            This can be a chain of properties of the form <code>vm =&gt; vm.Foo.Bar.Baz</code>
            and the binder will attempt to subscribe to changes on each recursively.
            </param>
            <param name="viewProperty">
            The property on the view that is to be bound.
            This can be a chain of properties of the form <code>view => view.Foo.Bar.Baz</code>
            and the binder will attempt to set the last one each time the view model property is updated.
            </param>
            <param name="vmToViewConverter">
            Delegate to convert the value of the view model's property's type to a value of the
            view's property's type.
            </param>
            <param name="viewToVmConverter">
            Delegate to convert the value of the view's property's type to a value of the
            view model's property's type.
            </param>
            <returns>
            An instance of <see cref="T:System.IDisposable"/> that, when disposed,
            disconnects the binding.
            </returns>
        </member>
        <member name="M:ReactiveUI.BindingMixins.Bind``5(``1,``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``3}},System.IObservable{``4},System.Func{``2,``3},System.Func{``3,``2})">
            <summary>
            Binds the specified view model property to the given view property.
            </summary>
            <typeparam name="TViewModel">The type of the view model being bound.</typeparam>
            <typeparam name="TView">The type of the view being bound.</typeparam>
            <typeparam name="TVMProp">The type of the property bound on the view model.</typeparam>
            <typeparam name="TVProp">The type of the property bound on the view.</typeparam>
            /// <typeparam name="TDontCare">
            A dummy type, only the fact that <paramref name="signalViewUpdate"/> 
            emits values is considered, not the actual values emitted.
            </typeparam>
            <param name="view">The instance of the view to bind.</param>
            <param name="viewModel">The instance of the view model to bind.</param>
            <param name="vmProperty">
            An expression indicating the property that is bound on the view model.
            This can be a chain of properties of the form <code>vm =&gt; vm.Foo.Bar.Baz</code>
            and the binder will attempt to subscribe to changes on each recursively.
            </param>
            <param name="viewProperty">
            The property on the view that is to be bound.
            This can be a chain of properties of the form <code>view => view.Foo.Bar.Baz</code>
            and the binder will attempt to set the last one each time the view model property is updated.
            </param>
            <param name="signalViewUpdate">
            An observable, that when signaled, indicates that the view property 
            has been changed, and that the binding should update the view model
            property accordingly.
            </param>
            <param name="vmToViewConverter">
            Delegate to convert the value of the view model's property's type to a value of the
            view's property's type.
            </param>
            <param name="viewToVmConverter">
            Delegate to convert the value of the view's property's type to a value of the
            view model's property's type.
            </param>
            <returns>
            An instance of <see cref="T:System.IDisposable"/> that, when disposed,
            disconnects the binding.
            </returns>
        </member>
        <member name="M:ReactiveUI.BindingMixins.OneWayBind``4(``1,``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``3}},System.Object,ReactiveUI.IBindingTypeConverter)">
            <summary>
            Binds the given property on the view model to a given property on the view in a one-way (view model to view) fashion.
            </summary>
            <typeparam name="TViewModel">The type of the view model.</typeparam>
            <typeparam name="TView">The type of the view.</typeparam>
            <typeparam name="TVMProp">The type of view model property.</typeparam>
            <typeparam name="TVProp">The type of the property bound on the view.</typeparam>
            <param name="view">
            The instance of the view object which is bound. Usually, it is the <code>this</code>
            instance.
            </param>
            <param name="viewModel">
            The view model that is bound. 
            It is usually set to the <see cref="P:ReactiveUI.IViewFor.ViewModel"/> property of the <paramref name="view"/>.</param>
            <param name="vmProperty">
            An expression indicating the property that is bound on the view model.
            This can be a chain of properties of the form <code>vm => vm.Foo.Bar.Baz</code>
            and the binder will attempt to subscribe to changes on each recursively.
            </param>
            <param name="viewProperty">
            The property on the view that is to be bound.
            This can be a chain of properties of the form <code>view => view.Foo.Bar.Baz</code>
            and the binder will attempt to set the last one each time the view model property is updated.
            </param>
            <param name="conversionHint">
            An object that can provide a hint for the converter.
            The semantics of this object is defined by the converter used.
            </param>
            <param name="vmToViewConverterOverride">
            An optional <see cref="T:ReactiveUI.IBindingTypeConverter"/> to use when converting from the 
            viewModel to view property.
            </param>
            <returns>
            An instance of <see cref="T:System.IDisposable"/> that, when disposed,
            disconnects the binding.
            </returns>
        </member>
        <member name="M:ReactiveUI.BindingMixins.OneWayBind``4(``1,``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``3}},System.Func{``2,``3})">
            <summary>
            Binds the specified view model property to the given view, in a one-way (view model to view) fashion,
            with the value of the view model property mapped through a <paramref name="selector"/> function.
            </summary>
            <typeparam name="TViewModel">The type of the view model that is bound.</typeparam>
            <typeparam name="TView">The type of the view that is bound.</typeparam>
            <typeparam name="TProp">The type of the property bound on the view model.</typeparam>
            <typeparam name="TOut">The return type of the <paramref name="selector"/>.</typeparam>
            <param name="viewModel">The instance of the view model to bind to.</param>
            <param name="view">The instance of the view to bind to.</param>
            <param name="vmProperty">
            An expression representing the property to be bound to on the view model.
            This can be a child property, for example <c>x =&gt; x.Foo.Bar.Baz</c> in which case
            the binding will attempt to subscribe recursively to updates in order to
            always get the last value of the property chain.
            </param>
            <param name="viewProperty">
            An expression representing the property to be bound to on the view.
            This can be a child property, for example <c>x =&gt; x.Foo.Bar.Baz</c> in which case
            the binding will attempt to subscribe recursively to updates in order to
            always set the correct property.
            </param>
            <param name="selector">
            A function that will be used to transform the values of the property on the view model
            before being bound to the view property.
            </param>
            <returns>
            An instance of <see cref="T:System.IDisposable"/> that, when disposed,
            disconnects the binding.
            </returns>
        </member>
        <member name="M:ReactiveUI.BindingMixins.BindTo``3(System.IObservable{``0},``1,System.Linq.Expressions.Expression{System.Func{``1,``2}},System.Object,ReactiveUI.IBindingTypeConverter)">
            <summary>
            BindTo takes an Observable stream and applies it to a target
            property. Conceptually it is similar to <c>Subscribe(x =&gt;
            target.property = x)</c>, but allows you to use child properties
            without the null checks.
            </summary>
            <typeparam name="TValue">The source type.</typeparam>
            <typeparam name="TTarget">The target object type.</typeparam>
            <typeparam name="TTValue">The type of the property on the target object.</typeparam>
            <param name="This">The observable stream to bind to a target property</param>
            <param name="target">The target object whose property will be set.</param>
            <param name="property">
            An expression representing the target property to set. 
            This can be a child property (i.e. <c>x.Foo.Bar.Baz</c>).
            </param>
            <param name="conversionHint">
            An object that can provide a hint for the converter.
            The semantics of this object is defined by the converter used.
            </param>
            <param name="vmToViewConverterOverride">
            An optional <see cref="T:ReactiveUI.IBindingTypeConverter"/> to use when converting from the 
            viewModel to view property.
            </param>
            <returns>An object that when disposed, disconnects the binding.</returns>
        </member>
        <member name="T:ReactiveUI.IPropertyBinderImplementation">
            <summary>
            This interface represents an object that is capable
            of providing binding implementations.
            </summary>
        </member>
        <member name="M:ReactiveUI.IPropertyBinderImplementation.Bind``5(``0,``1,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``3}},System.IObservable{``4},System.Object,ReactiveUI.IBindingTypeConverter,ReactiveUI.IBindingTypeConverter)">
            <summary>
            Creates a two-way binding between a view model and a view.
            This binding will attempt to convert the values of the 
            view and view model properties using a <see cref="T:ReactiveUI.IBindingTypeConverter"/>
            if they are not of the same type.
            </summary>
            <typeparam name="TViewModel">The type of the view model that is bound.</typeparam>
            <typeparam name="TView">The type of the view model that is bound.</typeparam>
            <typeparam name="TVMProp">The type of the property bound on the view model.</typeparam>
            <typeparam name="TVProp">The type of the property bound on the view.</typeparam>
            <typeparam name="TDontCare">
            A dummy type, only the fact that <paramref name="signalViewUpdate"/> 
            emits values is considered, not the actual values emitted.
            </typeparam>
            <param name="viewModel">The instance of the view model object to be bound.</param>
            <param name="view">The instance of the view object to be bound.</param>
            <param name="vmProperty">
            An expression representing the property to be bound to on the view model.
            This can be a child property, for example <c>x =&gt; x.Foo.Bar.Baz</c> in which case
            the binding will attempt to subscribe recursively to updates in order to
            always get and set the correct property.
            </param>
            <param name="viewProperty">
            An expression representing the property to be bound to on the view.
            This can be a child property, for example <c>x =&gt; x.Foo.Bar.Baz</c> in which case
            the binding will attempt to subscribe recursively to updates in order to
            always get and set the correct property.
            </param>
            <param name="signalViewUpdate">
            An observable, that when signaled, indicates that the view property 
            has been changed, and that the binding should update the view model
            property accordingly.
            </param>
            <param name="conversionHint">
            An object that can provide a hint for the converter.
            The semantics of this object is defined by the converter used.
            </param>
            <param name="vmToViewConverterOverride">
            An optional <see cref="T:ReactiveUI.IBindingTypeConverter"/> to use when converting from the 
            viewModel to view property.
            </param>
            <param name="viewToVMConverterOverride">
            An optional <see cref="T:ReactiveUI.IBindingTypeConverter"/> to use when converting from the 
            view to viewModel property.
            </param>
            <returns>
            An instance of <see cref="T:System.IDisposable"/> that, when disposed,
            disconnects the binding.
            </returns>
        </member>
        <member name="M:ReactiveUI.IPropertyBinderImplementation.Bind``5(``0,``1,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``3}},System.IObservable{``4},System.Func{``2,``3},System.Func{``3,``2})">
            <summary>
            Creates a two-way binding between a view model and a view.
            This binding will attempt to convert the values of the 
            view and view model properties using a <see cref="T:ReactiveUI.IBindingTypeConverter"/>
            if they are not of the same type.
            </summary>
            <typeparam name="TViewModel">The type of the view model that is bound.</typeparam>
            <typeparam name="TView">The type of the view model that is bound.</typeparam>
            <typeparam name="TVMProp">The type of the property bound on the view model.</typeparam>
            <typeparam name="TVProp">The type of the property bound on the view.</typeparam>
            <typeparam name="TDontCare">
            A dummy type, only the fact that <paramref name="signalViewUpdate"/> 
            emits values is considered, not the actual values emitted.
            </typeparam>
            <param name="viewModel">The instance of the view model object to be bound.</param>
            <param name="view">The instance of the view object to be bound.</param>
            <param name="vmProperty">
            An expression representing the property to be bound to on the view model.
            This can be a child property, for example <c>x =&gt; x.Foo.Bar.Baz</c> in which case
            the binding will attempt to subscribe recursively to updates in order to
            always get and set the correct property.
            </param>
            <param name="viewProperty">
            An expression representing the property to be bound to on the view.
            This can be a child property, for example <c>x =&gt; x.Foo.Bar.Baz</c> in which case
            the binding will attempt to subscribe recursively to updates in order to
            always get and set the correct property.
            </param>
            <param name="signalViewUpdate">
            An observable, that when signaled, indicates that the view property 
            has been changed, and that the binding should update the view model
            property accordingly.
            </param>
            <param name="vmToViewConverter">
            Delegate to convert the value of the view model's property's type to a value of the
            view's property's type.
            </param>
            <param name="viewToVmConverter">
            Delegate to convert the value of the view's property's type to a value of the
            view model's property's type.
            </param>
            <returns>
            An instance of <see cref="T:System.IDisposable"/> that, when disposed,
            disconnects the binding.
            </returns>
        </member>
        <member name="M:ReactiveUI.IPropertyBinderImplementation.OneWayBind``4(``0,``1,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``3}},System.Object,ReactiveUI.IBindingTypeConverter)">
            <summary>
            Creates a one-way binding, i.e. a binding that flows from the
            <paramref name="viewModel"/> to the <paramref name="view"/> only. This binding will
            attempt to convert the value of the view model property to the view property if they
            are not of the same type.
            </summary>
            <typeparam name="TViewModel">The type of the view model that is bound.</typeparam>
            <typeparam name="TView">The type of the view that is bound.</typeparam>
            <typeparam name="TVMProp">The type of the property bound on the view model.</typeparam>
            <typeparam name="TVProp">The type of the property bound on the view</typeparam>
            <param name="viewModel">The instance of the view model to bind to.</param>
            <param name="view">The instance of the view to bind to.</param>
            <param name="vmProperty">
            An expression representing the property to be bound to on the view model.
            This can be a child property, for example <c>x =&gt; x.Foo.Bar.Baz</c> in which case
            the binding will attempt to subscribe recursively to updates in order to
            always get the last value of the property chain.
            </param>
            <param name="viewProperty">
            An expression representing the property to be bound to on the view.
            This can be a child property, for example <c>x =&gt; x.Foo.Bar.Baz</c> in which case
            the binding will attempt to subscribe recursively to updates in order to
            always set the correct property.
            </param>
            <param name="conversionHint">
            An object that can provide a hint for the converter.
            The semantics of this object is defined by the converter used.
            </param>
            <param name="vmToViewConverterOverride">
            An optional <see cref="T:ReactiveUI.IBindingTypeConverter"/> to use when converting from the 
            viewModel to view property.
            </param>
            <returns>
            An instance of <see cref="T:System.IDisposable"/> that, when disposed,
            disconnects the binding.
            </returns>      
            <exception cref="T:System.ArgumentException">
            There is no registered converter from <typeparamref name="TVMProp"/> to <typeparamref name="TVProp"/>.
            </exception>
        </member>
        <member name="M:ReactiveUI.IPropertyBinderImplementation.OneWayBind``4(``0,``1,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``3}},System.Func{``2,``3})">
            <summary>
            Creates a one way binding with a selector, i.e. a binding that flows from the
            <paramref name="viewModel"/> to the <paramref name="view"/> only, and where the value of the view model
            property is mapped through the <paramref name="selector"/> before being set to the view.
            </summary>
            <typeparam name="TViewModel">The type of the view model that is bound.</typeparam>
            <typeparam name="TView">The type of the view that is bound.</typeparam>
            <typeparam name="TProp">The type of the property bound on the view model.</typeparam>
            <typeparam name="TOut">The return type of the <paramref name="selector"/>.</typeparam>
            <param name="viewModel">The instance of the view model to bind to.</param>
            <param name="view">The instance of the view to bind to.</param>
            <param name="vmProperty">
            An expression representing the property to be bound to on the view model.
            This can be a child property, for example <c>x =&gt; x.Foo.Bar.Baz</c> in which case
            the binding will attempt to subscribe recursively to updates in order to
            always get the last value of the property chain.
            </param>
            <param name="viewProperty">
            An expression representing the property to be bound to on the view.
            This can be a child property, for example <c>x =&gt; x.Foo.Bar.Baz</c> in which case
            the binding will attempt to subscribe recursively to updates in order to
            always set the correct property.
            </param>
            <param name="selector">
            A function that will be used to transform the values of the property on the view model
            before being bound to the view property.
            </param>
            <returns>
            An instance of <see cref="T:System.IDisposable"/> that, when disposed,
            disconnects the binding.
            </returns>
        </member>
        <member name="M:ReactiveUI.IPropertyBinderImplementation.BindTo``3(System.IObservable{``0},``1,System.Linq.Expressions.Expression{System.Func{``1,``2}},System.Object,ReactiveUI.IBindingTypeConverter)">
            <summary>
            BindTo takes an Observable stream and applies it to a target
            property. Conceptually it is similar to <c>Subscribe(x =&gt;
            target.property = x)</c>, but allows you to use child properties
            without the null checks.
            </summary>
            <param name="This">The target observable to bind to.</param>
            <param name="target">The target object whose property will be set.</param>
            <param name="property">
            An expression representing the target property to set. 
            This can be a child property (i.e. <c>x.Foo.Bar.Baz</c>).
            </param>
            <param name="conversionHint">
            An object that can provide a hint for the converter.
            The semantics of this object is defined by the converter used.
            </param>
            <param name="vmToViewConverterOverride">
            An optional <see cref="T:ReactiveUI.IBindingTypeConverter"/> to use when converting from the 
            viewModel to view property.
            </param>  
            <returns>An object that when disposed, disconnects the binding.</returns>
        </member>
        <member name="T:ReactiveUI.PropertyBinderImplementation">
            <summary>
            Provides methods to bind properties to observables.
            </summary>
        </member>
        <member name="M:ReactiveUI.PropertyBinderImplementation.Bind``5(``0,``1,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``3}},System.IObservable{``4},System.Object,ReactiveUI.IBindingTypeConverter,ReactiveUI.IBindingTypeConverter)">
            <summary>
            Creates a two-way binding between a view model and a view.
            This binding will attempt to convert the values of the 
            view and view model properties using a <see cref="T:ReactiveUI.IBindingTypeConverter"/>
            if they are not of the same type.
            </summary>
            <typeparam name="TViewModel">The type of the view model that is bound.</typeparam>
            <typeparam name="TView">The type of the view model that is bound.</typeparam>
            <typeparam name="TVMProp">The type of the property bound on the view model.</typeparam>
            <typeparam name="TVProp">The type of the property bound on the view.</typeparam>
            <typeparam name="TDontCare">
            A dummy type, only the fact that <paramref name="signalViewUpdate"/> 
            emits values is considered, not the actual values emitted.
            </typeparam>
            <param name="viewModel">The instance of the view model object to be bound.</param>
            <param name="view">The instance of the view object to be bound.</param>
            <param name="vmProperty">
            An expression representing the property to be bound to on the view model.
            This can be a child property, for example <c>x =&gt; x.Foo.Bar.Baz</c> in which case
            the binding will attempt to subscribe recursively to updates in order to
            always get and set the correct property.
            </param>
            <param name="viewProperty">
            An expression representing the property to be bound to on the view.
            This can be a child property, for example <c>x =&gt; x.Foo.Bar.Baz</c> in which case
            the binding will attempt to subscribe recursively to updates in order to
            always get and set the correct property.
            
            If it is left null, the framework will attempt to automagically figure out
            the control and property that is to be bound, by looking for a control of the
            same name as the <paramref name="vmProperty"/>, and its most natural property.
            </param>
            <param name="signalViewUpdate">
            An observable, that when signaled, indicates that the view property 
            has been changed, and that the binding should update the view model
            property accordingly.
            </param>
            <param name="conversionHint">
            An object that can provide a hint for the converter.
            The semantics of this object is defined by the converter used.
            </param>
            <param name="vmToViewConverterOverride">
            An optional <see cref="T:ReactiveUI.IBindingTypeConverter"/> to use when converting from the 
            viewModel to view property.
            </param>
            <param name="viewToVMConverterOverride">
            An optional <see cref="T:ReactiveUI.IBindingTypeConverter"/> to use when converting from the 
            view to viewModel property.
            </param>
            <returns>
            An instance of <see cref="T:System.IDisposable"/> that, when disposed,
            disconnects the binding.
            </returns>
        </member>
        <member name="M:ReactiveUI.PropertyBinderImplementation.Bind``5(``0,``1,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``3}},System.IObservable{``4},System.Func{``2,``3},System.Func{``3,``2})">
            <summary>
            Binds the specified view model property to the given view property.
            </summary>
            <typeparam name="TViewModel">The type of the view model being bound.</typeparam>
            <typeparam name="TView">The type of the view being bound.</typeparam>
            <typeparam name="TVMProp">The type of the property bound on the view model.</typeparam>
            <typeparam name="TVProp">The type of the property bound on the view.</typeparam>
            <typeparam name="TDontCare">
            A dummy type, only the fact that <paramref name="signalViewUpdate"/> 
            emits values is considered, not the actual values emitted.
            </typeparam>
            <param name="view">The instance of the view to bind.</param>
            <param name="viewModel">The instance of the view model to bind.</param>
            <param name="vmProperty">
            An expression indicating the property that is bound on the view model.
            This can be a chain of properties of the form <c>vm =&gt; vm.Foo.Bar.Baz</c>
            and the binder will attempt to subscribe to changes on each recursively.
            </param>
            <param name="viewProperty">
            The property on the view that is to be bound.
            This can be a chain of properties of the form <code>view => view.Foo.Bar.Baz</code>
            and the binder will attempt to set the last one each time the view model property is updated.
            </param>
            <param name="signalViewUpdate">
            An observable, that when signaled, indicates that the view property 
            has been changed, and that the binding should update the view model
            property accordingly.
            </param>
            <param name="vmToViewConverter">
            Delegate to convert the value of the view model's property's type to a value of the
            view's property's type.
            </param>
            <param name="viewToVmConverter">
            Delegate to convert the value of the view's property's type to a value of the
            view model's property's type.
            </param>
            <returns>
            An instance of <see cref="T:System.IDisposable"/> that, when disposed,
            disconnects the binding.
            </returns>
        </member>
        <member name="M:ReactiveUI.PropertyBinderImplementation.OneWayBind``4(``0,``1,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``3}},System.Object,ReactiveUI.IBindingTypeConverter)">
            <summary>
            Creates a one-way binding, i.e. a binding that flows from the
            <paramref name="viewModel"/> to the <paramref name="view"/> only. This binding will
            attempt to convert the value of the view model property to the view property if they
            are not of the same type.
            </summary>
            <typeparam name="TViewModel">The type of the view model that is bound.</typeparam>
            <typeparam name="TView">The type of the view that is bound.</typeparam>
            <typeparam name="TVMProp">The type of the property bound on the view model.</typeparam>
            <typeparam name="TVProp">The type of the property bound on the view</typeparam>
            <param name="viewModel">The instance of the view model to bind to.</param>
            <param name="view">The instance of the view to bind to.</param>
            <param name="vmProperty">
            An expression representing the property to be bound to on the view model.
            This can be a child property, for example <c>x =&gt; x.Foo.Bar.Baz</c> in which case
            the binding will attempt to subscribe recursively to updates in order to
            always get the last value of the property chain.
            </param>
            <param name="viewProperty">
            An expression representing the property to be bound to on the view.
            This can be a child property, for example <c>x =&gt; x.Foo.Bar.Baz</c> in which case
            the binding will attempt to subscribe recursively to updates in order to
            always set the correct property.
            
            If it is left null, the framework will attempt to automagically figure out
            the control and property that is to be bound, by looking for a control of the
            same name as the <paramref name="vmProperty"/>, and its most natural property.
            </param>
            <param name="conversionHint">
            An object that can provide a hint for the converter.
            The semantics of this object is defined by the converter used.
            </param>
            <param name="vmToViewConverterOverride">
            Delegate to convert the value of the view model's property's type to a value of the
            view's property's type.
            </param>
            <returns>
            An instance of <see cref="T:System.IDisposable"/> that, when disposed,
            disconnects the binding.
            </returns>
            <exception cref="T:System.ArgumentException">
            There is no registered converter from <typeparamref name="TVMProp"/> to <typeparamref name="TVProp"/>.
            </exception>
        </member>
        <member name="M:ReactiveUI.PropertyBinderImplementation.OneWayBind``4(``0,``1,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``1,``3}},System.Func{``2,``3})">
            <summary>
            Creates a one way binding with a selector, i.e. a binding that flows from the
            <paramref name="viewModel"/> to the <paramref name="view"/> only, and where the value of the view model
            property is mapped through the <paramref name="selector"/> before being set to the view.
            </summary>
            <typeparam name="TViewModel">The type of the view model that is bound.</typeparam>
            <typeparam name="TView">The type of the view that is bound.</typeparam>
            <typeparam name="TProp">The type of the property bound on the view model.</typeparam>
            <typeparam name="TOut">The return type of the <paramref name="selector"/>.</typeparam>
            <param name="viewModel">The instance of the view model to bind to.</param>
            <param name="view">The instance of the view to bind to.</param>
            <param name="vmProperty">
            An expression representing the property to be bound to on the view model.
            This can be a child property, for example <c>x =&gt; x.Foo.Bar.Baz</c> in which case
            the binding will attempt to subscribe recursively to updates in order to
            always get the last value of the property chain.
            </param>
            <param name="viewProperty">
            An expression representing the property to be bound to on the view.
            This can be a child property, for example <c>x =&gt; x.Foo.Bar.Baz</c> in which case
            the binding will attempt to subscribe recursively to updates in order to
            always set the correct property.
            
            If it is left null, the framework will attempt to automagically figure out
            the control and property that is to be bound, by looking for a control of the
            same name as the <paramref name="vmProperty"/>, and its most natural property.
            </param>
            <param name="selector">
            A function that will be used to transform the values of the property on the view model
            before being bound to the view property.
            </param>
            <returns>
            An instance of <see cref="T:System.IDisposable"/> that, when disposed,
            disconnects the binding.
            </returns>
        </member>
        <member name="M:ReactiveUI.PropertyBinderImplementation.BindTo``3(System.IObservable{``0},``1,System.Linq.Expressions.Expression{System.Func{``1,``2}},System.Object,ReactiveUI.IBindingTypeConverter)">
            <summary>
            BindTo takes an Observable stream and applies it to a target
            property. Conceptually it is similar to <c>Subscribe(x =&gt;
            target.property = x)</c>, but allows you to use child properties
            without the null checks.
            </summary>
            <typeparam name="TValue">The source type.</typeparam>
            <typeparam name="TTarget">The target object type.</typeparam>
            <typeparam name="TTValue">The type of the property on the target object.</typeparam>
            <param name="target">The target object whose property will be set.</param>
            <param name="property">
            An expression representing the target property to set. 
            This can be a child property (i.e. <c>x.Foo.Bar.Baz</c>).</param>
            <param name="This">The observable to apply to the target property.</param>
            <param name="conversionHint">
            An object that can provide a hint for the converter.
            The semantics of this object is defined by the converter used.
            </param>
            <param name="vmToViewConverterOverride">
            Delegate to convert the value of the view model's property's type to a value of the
            view's property's type.
            </param>
            <returns>An object that when disposed, disconnects the binding.</returns>
        </member>
        <member name="T:ReactiveUI.ReactiveDerivedCollection`1">
            <summary>
            This class represents a change-notifying Collection which is derived from
            a source collection, via CreateDerivedCollection or via another method. 
            It is read-only, and any attempts to change items in the collection will
            fail.
            </summary>
        </member>
        <member name="T:ReactiveUI.ReactiveDerivedCollection`2">
            <summary>
            This class represents a change-notifying Collection which is derived from
            a source collection, via CreateDerivedCollection or via another method. 
            It is read-only, and any attempts to change items in the collection will
            fail.
            </summary>
        </member>
        <member name="M:ReactiveUI.ReactiveDerivedCollection`2.canItemStayAtPosition(`1,System.Int32)">
            <summary>
            Gets a value indicating whether or not the item fits (sort-wise) at the provided index. The determination
            is made by checking whether or not it's considered larger than or equal to the preceeding item and if
            it's less than or equal to the succeeding item.
            </summary>
        </member>
        <member name="M:ReactiveUI.ReactiveDerivedCollection`2.getIndexFromSourceIndex(System.Int32)">
            <summary>
            Gets the index of the dervived item based on it's originating element index in the source collection.
            </summary>
        </member>
        <member name="M:ReactiveUI.ReactiveDerivedCollection`2.indexOfAll(System.Collections.Generic.IEnumerable{`0},`0,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Returns one or more positions in the source collection where the given item is found based on the
            provided equality comparer.
            </summary>
        </member>
        <member name="M:ReactiveUI.ReactiveDerivedCollection`2.moveSourceIndexInMap(System.Int32,System.Int32)">
            <summary>
            Increases (or decreases depending on move direction) all source indices between the source and destination
            move indices.
            </summary>
        </member>
        <member name="M:ReactiveUI.ReactiveDerivedCollection`2.shiftIndicesAtOrOverThreshold(System.Int32,System.Int32)">
            <summary>
            Increases (or decreases) all source indices equal to or higher than the threshold. Represents an
            insert or remove of one or more items in the source list thus causing all subsequent items to shift
            up or down.
            </summary>
        </member>
        <member name="M:ReactiveUI.ReactiveDerivedCollection`2.shiftSourceIndicesInRange(System.Int32,System.Int32,System.Int32)">
            <summary>
            Increases (or decreases) all source indices within the range (lower inclusive, upper exclusive). 
            </summary>
        </member>
        <member name="T:ReactiveUI.ReactiveDerivedCollection`2.ReferenceEqualityComparer`1">
            <summary>
            Internal equality comparer used for looking up the source object of a property change notification in
            the source list.
            </summary>
        </member>
        <member name="M:ReactiveUI.ReactiveDerivedCollection`2.newPositionForExistingItem(System.Int32,System.Int32,`1)">
            <summary>
            Calculates a new destination for an updated item that's already in the list.
            </summary>
        </member>
        <member name="M:ReactiveUI.ReactiveDerivedCollection`2.newPositionForExistingItem``1(System.Collections.Generic.IList{``0},``0,System.Int32,System.Func{``0,``0,System.Int32})">
            <summary>
            Calculates a new destination for an updated item that's already in the list.
            </summary>
        </member>
        <member name="T:ReactiveUI.ReactiveCollectionMixins">
            <summary>
            Extension methods to create collections from observables
            </summary>
        </member>
        <member name="M:ReactiveUI.ReactiveCollectionMixins.CreateCollection``1(System.IObservable{``0},System.Reactive.Concurrency.IScheduler)">
            <summary>
            Creates a collection based on an an Observable by adding items
            provided until the Observable completes. This method guarantees that
            items are always added in the context of the provided scheduler.
            </summary>
            <param name="fromObservable">
            The Observable whose items will be put into the new collection.
            </param>
            <param name="scheduler">
            Optionally specifies the scheduler on which
            the collection will be populated. Defaults to the main scheduler.
            </param>
            <returns>
            A new collection which will be populated with the Observable.
            </returns>
        </member>
        <member name="M:ReactiveUI.ReactiveCollectionMixins.CreateCollection``1(System.IObservable{``0},System.Nullable{System.TimeSpan},System.Action{System.Exception},System.Reactive.Concurrency.IScheduler)">
            <summary>
            Creates a collection based on an an Observable by adding items
            provided until the Observable completes, optionally ensuring a
            delay. Note that if the Observable never completes and withDelay is
            set, this method will leak a Timer. This method also guarantees that
            items are always added in the context of the provided scheduler.
            </summary>
            <param name="fromObservable">
            The Observable whose items will be put into the new collection.
            </param>
            <param name="onError">
            The handler for errors from the Observable. If not specified, 
            an error will go to DefaultExceptionHandler.
            </param>
            <param name="withDelay">
            If set, items will be populated in the collection no faster than the delay provided.
            </param>
            <param name="scheduler">
            Optionally specifies the scheduler on which the collection will be populated. 
            Defaults to the main scheduler.
            </param>
            <returns>
            A new collection which will be populated with the Observable.
            </returns>
        </member>
        <member name="T:ReactiveUI.ObservableCollectionMixin">
            <summary>
            Extension methods to create collections that "follow" other collections.
            </summary>
        </member>
        <member name="M:ReactiveUI.ObservableCollectionMixin.CreateDerivedCollection``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Action{``1},System.Func{``0,System.Boolean},System.Func{``1,``1,System.Int32},System.IObservable{``2},System.Reactive.Concurrency.IScheduler)">
             <summary>
             Creates a collection whose contents will "follow" another
             collection; this method is useful for creating ViewModel collections
             that are automatically updated when the respective Model collection
             is updated.
            
             Note that even though this method attaches itself to any 
             IEnumerable, it will only detect changes from objects implementing
             <see cref="T:System.Collections.Specialized.INotifyCollectionChanged"/> (like <see cref="T:ReactiveUI.ReactiveList`1"/>). 
             If your source collection doesn't implement this, <paramref name="signalReset"/> 
             is the way to signal the derived collection to reorder/refilter itself.
             </summary>
             <param name="This">
             The source <see cref="T:System.Collections.Generic.IEnumerable`1"/> to track.
             </param>
             <param name="selector">
             A Select function that will be run on each item.
             </param>
             <param name="onRemoved">
             An action that is called on each item when it is removed.
             </param>
             <param name="filter">
             A filter to determine whether to exclude items in the derived collection.
             </param>
             <param name="orderer">
             A comparator method to determine the ordering of the resulting collection.
             </param>
             <param name="signalReset">
             When this Observable is signalled, the derived collection will be manually 
             reordered/refiltered.
             </param>
             <param name="scheduler">
             An optional scheduler used to dispatch change notifications.
             </param>
             <returns>
             A new collection whose items are equivalent to
             <c>Collection.Select().Where().OrderBy()</c> and will mirror changes 
             in the initial collection.
             </returns>
        </member>
        <member name="M:ReactiveUI.ObservableCollectionMixin.CreateDerivedCollection``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,System.Boolean},System.Func{``1,``1,System.Int32},System.IObservable{``2},System.Reactive.Concurrency.IScheduler)">
             <summary>
             Creates a collection whose contents will "follow" another
             collection; this method is useful for creating ViewModel collections
             that are automatically updated when the respective Model collection
             is updated.
            
             Note that even though this method attaches itself to any 
             IEnumerable, it will only detect changes from objects implementing
             <see cref="T:System.Collections.Specialized.INotifyCollectionChanged"/> (like <see cref="T:ReactiveUI.ReactiveList`1"/>). 
             If your source collection doesn't implement this, <paramref name="signalReset"/> 
             is the way to signal the derived collection to reorder/refilter itself.
             </summary>
             <param name="This">
             The source <see cref="T:System.Collections.Generic.IEnumerable`1"/> to track.
             </param>
             <param name="selector">
             A Select function that will be run on each item.
             </param>
             <param name="filter">
             A filter to determine whether to exclude items in the derived collection.
             </param>
             <param name="orderer">
             A comparator method to determine the ordering of the resulting collection.
             </param>
             <param name="signalReset">
             When this Observable is signalled, the derived collection will be manually 
             reordered/refiltered.
             </param>
             <param name="scheduler">
             An optional scheduler used to dispatch change notifications.
             </param>
             <returns>
             A new collection whose items are equivalent to
             <c>Collection.Select().Where().OrderBy()</c> and will mirror changes 
             in the initial collection.
             </returns>
        </member>
        <member name="M:ReactiveUI.ObservableCollectionMixin.CreateDerivedCollection``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Action{``1},System.Func{``0,System.Boolean},System.Func{``1,``1,System.Int32},System.Reactive.Concurrency.IScheduler)">
             <summary>
             Creates a collection whose contents will "follow" another
             collection; this method is useful for creating ViewModel collections
             that are automatically updated when the respective Model collection
             is updated.
            
             Be aware that this overload will result in a collection that *only* 
             updates if the source implements INotifyCollectionChanged. If your
             list changes but isn't a ReactiveList/ObservableCollection,
             you probably want to use the other overload.
             </summary>
             <param name="This">
             The source <see cref="T:System.Collections.Generic.IEnumerable`1"/> to track.
             </param>
             <param name="selector">
             A Select function that will be run on each item.
             </param>
             <param name="onRemoved">
             An action that is called on each item when it is removed.
             </param>
             <param name="filter">
             A filter to determine whether to exclude items in the derived collection.
             </param>
             <param name="orderer">
             A comparator method to determine the ordering of the resulting collection.
             </param>
             <param name="scheduler">
             An optional scheduler used to dispatch change notifications.
             </param>
             <returns>
             A new collection whose items are equivalent to
             <c>Collection.Select().Where().OrderBy()</c> and will mirror changes 
             in the initial collection.
             </returns>
        </member>
        <member name="M:ReactiveUI.ObservableCollectionMixin.CreateDerivedCollection``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,System.Boolean},System.Func{``1,``1,System.Int32},System.Reactive.Concurrency.IScheduler)">
             <summary>
             Creates a collection whose contents will "follow" another
             collection; this method is useful for creating ViewModel collections
             that are automatically updated when the respective Model collection
             is updated.
            
             Be aware that this overload will result in a collection that *only* 
             updates if the source implements INotifyCollectionChanged. If your
             list changes but isn't a ReactiveList/ObservableCollection,
             you probably want to use the other overload.
             </summary>
             <param name="This">
             The source <see cref="T:System.Collections.Generic.IEnumerable`1"/> to track.
             </param>
             <param name="selector">
             A Select function that will be run on each item.
             </param>
             <param name="filter">
             A filter to determine whether to exclude items in the derived collection.
             </param>
             <param name="orderer">
             A comparator method to determine the ordering of the resulting collection.
             </param>
             <param name="scheduler">
             An optional scheduler used to dispatch change notifications.
             </param>
             <returns>
             A new collection whose items are equivalent to
             <c>Collection.Select().Where().OrderBy()</c> and will mirror changes 
             in the initial collection.
             </returns>
        </member>
        <member name="T:ReactiveUI.ReactiveCommand">
            <summary>
            Encapsulates a user action behind a reactive interface.
            </summary>
            <remarks>
            <para>
            This non-generic base class defines the base behavior for all reactive commands.
            </para>
            <para>
            Reactive commands encapsulate the behavior of running some execution logic and then surfacing the results on the UI
            thread. Importantly, no scheduling is performed against input observables (the <c>canExecute</c> and execution pipelines).
            </para>
            <para>
            To create an instance of <c>ReactiveCommand</c>, call one of the static creation methods defined by this class.
            <see cref="M:ReactiveUI.ReactiveCommand.Create(System.Action,System.IObservable{System.Boolean},System.Reactive.Concurrency.IScheduler)"/> can be used when your execution logic is synchronous. <see cref="M:ReactiveUI.ReactiveCommand.CreateFromObservable``1(System.Func{System.IObservable{``0}},System.IObservable{System.Boolean},System.Reactive.Concurrency.IScheduler)"/> and
            <see cref="M:ReactiveUI.ReactiveCommand.CreateFromTask(System.Func{System.Threading.Tasks.Task},System.IObservable{System.Boolean},System.Reactive.Concurrency.IScheduler)"/> can be used for asynchronous execution logic. Optionally, you can provide an observable that
            governs the availability of the command for execution, as well as a scheduler to which events will be delivered.
            </para>
            <para>
            The <see cref="P:ReactiveUI.ReactiveCommand.CanExecute"/> property provides an observable that can be used to determine whether the command is
            eligible for execution. The value of this observable is determined by both the <c>canExecute</c> observable provided
            during command creation, and the current execution status of the command. A command that is already executing will
            yield <c>false</c> from its <see cref="P:ReactiveUI.ReactiveCommand.CanExecute"/> observable regardless of the <c>canExecute</c> observable provided
            during command creation.
            </para>
            <para>
            The <see cref="P:ReactiveUI.ReactiveCommand.IsExecuting"/> property provides an observable whose value indicates whether the command is currently
            executing. This can be a useful means of triggering UI, such as displaying an activity indicator whilst a command is
            executing.
            </para>
            <para>
            As discussed above, you are under no obligation to somehow incorporate this into your <c>canExecute</c> observable
            because that is taken care of for you. That is, if the value of <c>IsExecuting</c> is <c>true</c>, the value of
            <c>CanExecute</c> will be <c>false</c>. However, if the value of <c>CanExecute</c> is <c>false</c>, that does not imply
            the value of <c>IsExecuting</c> is <c>true</c>.
            </para>
            <para>
            Any errors in your command's execution logic (including any <c>canExecute</c> observable you choose to provide) will be
            surfaced via the <see cref="P:ReactiveUI.ReactiveCommand.ThrownExceptions"/> observable. This gives you the opportunity to handle the error before
            it triggers a default handler that tears down the application. For example, you might use this as a means of alerting
            the user that something has gone wrong executing the command.
            </para>
            <para>
            For the sake of convenience, all <c>ReactiveCommand</c> instances are also implementations of <see cref="T:System.Windows.Input.ICommand"/>.
            This allows you to easily integrate instances of <c>ReactiveCommand</c> into platforms that understands <c>ICommand</c>
            natively (such as WPF and UWP).
            </para>
            </remarks>
        </member>
        <member name="M:ReactiveUI.ReactiveCommand.Create(System.Action,System.IObservable{System.Boolean},System.Reactive.Concurrency.IScheduler)">
            <summary>
            Creates a parameterless <see cref="T:ReactiveUI.ReactiveCommand`2"/> with synchronous execution logic.
            </summary>
            <param name="execute">
            The action to execute whenever the command is executed.
            </param>
            <param name="canExecute">
            An optional observable that dictates the availability of the command for execution.
            </param>
            <param name="outputScheduler">
            An optional scheduler that is used to surface events. Defaults to <c>RxApp.MainThreadScheduler</c>.
            </param>
            <returns>
            The <c>ReactiveCommand</c> instance.
            </returns>
        </member>
        <member name="M:ReactiveUI.ReactiveCommand.Create``1(System.Func{``0},System.IObservable{System.Boolean},System.Reactive.Concurrency.IScheduler)">
            <summary>
            Creates a parameterless <see cref="T:ReactiveUI.ReactiveCommand`2"/> with synchronous execution logic that returns a value
            of type <typeparamref name="TResult"/>.
            </summary>
            <param name="execute">
            The function to execute whenever the command is executed.
            </param>
            <param name="canExecute">
            An optional observable that dictates the availability of the command for execution.
            </param>
            <param name="outputScheduler">
            An optional scheduler that is used to surface events. Defaults to <c>RxApp.MainThreadScheduler</c>.
            </param>
            <returns>
            The <c>ReactiveCommand</c> instance.
            </returns>
            <typeparam name="TResult">
            The type of value returned by command executions.
            </typeparam>
        </member>
        <member name="M:ReactiveUI.ReactiveCommand.Create``1(System.Action{``0},System.IObservable{System.Boolean},System.Reactive.Concurrency.IScheduler)">
            <summary>
            Creates a <see cref="T:ReactiveUI.ReactiveCommand`2"/> with synchronous execution logic that takes a parameter of type <typeparamref name="TParam"/>.
            </summary>
            <param name="execute">
            The action to execute whenever the command is executed.
            </param>
            <param name="canExecute">
            An optional observable that dictates the availability of the command for execution.
            </param>
            <param name="outputScheduler">
            An optional scheduler that is used to surface events. Defaults to <c>RxApp.MainThreadScheduler</c>.
            </param>
            <returns>
            The <c>ReactiveCommand</c> instance.
            </returns>
            <typeparam name="TParam">
            The type of the parameter passed through to command execution.
            </typeparam>
        </member>
        <member name="M:ReactiveUI.ReactiveCommand.Create``2(System.Func{``0,``1},System.IObservable{System.Boolean},System.Reactive.Concurrency.IScheduler)">
            <summary>
            Creates a <see cref="T:ReactiveUI.ReactiveCommand`2"/> with synchronous execution logic that takes a parameter of type <typeparamref name="TParam"/>
            and returns a value of type <typeparamref name="TResult"/>.
            </summary>
            <param name="execute">
            The function to execute whenever the command is executed.
            </param>
            <param name="canExecute">
            An optional observable that dictates the availability of the command for execution.
            </param>
            <param name="outputScheduler">
            An optional scheduler that is used to surface events. Defaults to <c>RxApp.MainThreadScheduler</c>.
            </param>
            <returns>
            The <c>ReactiveCommand</c> instance.
            </returns>
            <typeparam name="TParam">
            The type of the parameter passed through to command execution.
            </typeparam>
            <typeparam name="TResult">
            The type of value returned by command executions.
            </typeparam>
        </member>
        <member name="M:ReactiveUI.ReactiveCommand.CreateFromObservable``1(System.Func{System.IObservable{``0}},System.IObservable{System.Boolean},System.Reactive.Concurrency.IScheduler)">
            <summary>
            Creates a parameterless <see cref="T:ReactiveUI.ReactiveCommand`2"/> with asynchronous execution logic.
            </summary>
            <param name="execute">
            Provides an observable representing the command's asynchronous execution logic.
            </param>
            <param name="canExecute">
            An optional observable that dictates the availability of the command for execution.
            </param>
            <param name="outputScheduler">
            An optional scheduler that is used to surface events. Defaults to <c>RxApp.MainThreadScheduler</c>.
            </param>
            <returns>
            The <c>ReactiveCommand</c> instance.
            </returns>
            <typeparam name="TResult">
            The type of the command's result.
            </typeparam>
        </member>
        <member name="M:ReactiveUI.ReactiveCommand.CreateFromTask``1(System.Func{System.Threading.Tasks.Task{``0}},System.IObservable{System.Boolean},System.Reactive.Concurrency.IScheduler)">
            <summary>
            Creates a parameterless <see cref="T:ReactiveUI.ReactiveCommand`2"/> with asynchronous execution logic.
            </summary>
            <param name="execute">
            Provides a <see cref="T:System.Threading.Tasks.Task"/> representing the command's asynchronous execution logic.
            </param>
            <param name="canExecute">
            An optional observable that dictates the availability of the command for execution.
            </param>
            <param name="outputScheduler">
            An optional scheduler that is used to surface events. Defaults to <c>RxApp.MainThreadScheduler</c>.
            </param>
            <returns>
            The <c>ReactiveCommand</c> instance.
            </returns>
            <typeparam name="TResult">
            The type of the command's result.
            </typeparam>
        </member>
        <member name="M:ReactiveUI.ReactiveCommand.CreateFromTask``1(System.Func{System.Threading.CancellationToken,System.Threading.Tasks.Task{``0}},System.IObservable{System.Boolean},System.Reactive.Concurrency.IScheduler)">
            <summary>
            Creates a parameterless, cancellable <see cref="T:ReactiveUI.ReactiveCommand`2"/> with asynchronous execution logic.
            </summary>
            <param name="execute">
            Provides a <see cref="T:System.Threading.Tasks.Task"/> representing the command's asynchronous execution logic.
            </param>
            <param name="canExecute">
            An optional observable that dictates the availability of the command for execution.
            </param>
            <param name="outputScheduler">
            An optional scheduler that is used to surface events. Defaults to <c>RxApp.MainThreadScheduler</c>.
            </param>
            <returns>
            The <c>ReactiveCommand</c> instance.
            </returns>
            <typeparam name="TResult">
            The type of the command's result.
            </typeparam>
        </member>
        <member name="M:ReactiveUI.ReactiveCommand.CreateFromTask(System.Func{System.Threading.Tasks.Task},System.IObservable{System.Boolean},System.Reactive.Concurrency.IScheduler)">
            <summary>
            Creates a parameterless <see cref="T:ReactiveUI.ReactiveCommand`2"/> with asynchronous execution logic.
            </summary>
            <param name="execute">
            Provides a <see cref="T:System.Threading.Tasks.Task"/> representing the command's asynchronous execution logic.
            </param>
            <param name="canExecute">
            An optional observable that dictates the availability of the command for execution.
            </param>
            <param name="outputScheduler">
            An optional scheduler that is used to surface events. Defaults to <c>RxApp.MainThreadScheduler</c>.
            </param>
            <returns>
            The <c>ReactiveCommand</c> instance.
            </returns>
        </member>
        <member name="M:ReactiveUI.ReactiveCommand.CreateFromTask(System.Func{System.Threading.CancellationToken,System.Threading.Tasks.Task},System.IObservable{System.Boolean},System.Reactive.Concurrency.IScheduler)">
            <summary>
            Creates a parameterless, cancellable <see cref="T:ReactiveUI.ReactiveCommand`2"/> with asynchronous execution logic.
            </summary>
            <param name="execute">
            Provides a <see cref="T:System.Threading.Tasks.Task"/> representing the command's asynchronous execution logic.
            </param>
            <param name="canExecute">
            An optional observable that dictates the availability of the command for execution.
            </param>
            <param name="outputScheduler">
            An optional scheduler that is used to surface events. Defaults to <c>RxApp.MainThreadScheduler</c>.
            </param>
            <returns>
            The <c>ReactiveCommand</c> instance.
            </returns>
        </member>
        <member name="M:ReactiveUI.ReactiveCommand.CreateFromObservable``2(System.Func{``0,System.IObservable{``1}},System.IObservable{System.Boolean},System.Reactive.Concurrency.IScheduler)">
            <summary>
            Creates a <see cref="T:ReactiveUI.ReactiveCommand`2"/> with asynchronous execution logic that takes a parameter of type <typeparamref name="TParam"/>.
            </summary>
            <param name="execute">
            Provides an observable representing the command's asynchronous execution logic.
            </param>
            <param name="canExecute">
            An optional observable that dictates the availability of the command for execution.
            </param>
            <param name="outputScheduler">
            An optional scheduler that is used to surface events. Defaults to <c>RxApp.MainThreadScheduler</c>.
            </param>
            <returns>
            The <c>ReactiveCommand</c> instance.
            </returns>
            <typeparam name="TParam">
            The type of the parameter passed through to command execution.
            </typeparam>
            <typeparam name="TResult">
            The type of the command's result.
            </typeparam>
        </member>
        <member name="M:ReactiveUI.ReactiveCommand.CreateFromTask``2(System.Func{``0,System.Threading.Tasks.Task{``1}},System.IObservable{System.Boolean},System.Reactive.Concurrency.IScheduler)">
            <summary>
            Creates a <see cref="T:ReactiveUI.ReactiveCommand`2"/> with asynchronous execution logic that takes a parameter of type <typeparamref name="TParam"/>.
            </summary>
            <param name="execute">
            Provides a <see cref="T:System.Threading.Tasks.Task"/> representing the command's asynchronous execution logic.
            </param>
            <param name="canExecute">
            An optional observable that dictates the availability of the command for execution.
            </param>
            <param name="outputScheduler">
            An optional scheduler that is used to surface events. Defaults to <c>RxApp.MainThreadScheduler</c>.
            </param>
            <returns>
            The <c>ReactiveCommand</c> instance.
            </returns>
            <typeparam name="TParam">
            The type of the parameter passed through to command execution.
            </typeparam>
            <typeparam name="TResult">
            The type of the command's result.
            </typeparam>
        </member>
        <member name="M:ReactiveUI.ReactiveCommand.CreateFromTask``2(System.Func{``0,System.Threading.CancellationToken,System.Threading.Tasks.Task{``1}},System.IObservable{System.Boolean},System.Reactive.Concurrency.IScheduler)">
            <summary>
            Creates a <see cref="T:ReactiveUI.ReactiveCommand`2"/> with asynchronous, cancellable execution logic that takes a parameter of type <typeparamref name="TParam"/>.
            </summary>
            <param name="execute">
            Provides a <see cref="T:System.Threading.Tasks.Task"/> representing the command's asynchronous execution logic.
            </param>
            <param name="canExecute">
            An optional observable that dictates the availability of the command for execution.
            </param>
            <param name="outputScheduler">
            An optional scheduler that is used to surface events. Defaults to <c>RxApp.MainThreadScheduler</c>.
            </param>
            <returns>
            The <c>ReactiveCommand</c> instance.
            </returns>
            <typeparam name="TParam">
            The type of the parameter passed through to command execution.
            </typeparam>
            <typeparam name="TResult">
            The type of the command's result.
            </typeparam>
        </member>
        <member name="M:ReactiveUI.ReactiveCommand.CreateFromTask``1(System.Func{``0,System.Threading.Tasks.Task},System.IObservable{System.Boolean},System.Reactive.Concurrency.IScheduler)">
            <summary>
            Creates a <see cref="T:ReactiveUI.ReactiveCommand`2"/> with asynchronous execution logic that takes a parameter of type <typeparamref name="TParam"/>.
            </summary>
            <param name="execute">
            Provides a <see cref="T:System.Threading.Tasks.Task"/> representing the command's asynchronous execution logic.
            </param>
            <param name="canExecute">
            An optional observable that dictates the availability of the command for execution.
            </param>
            <param name="outputScheduler">
            An optional scheduler that is used to surface events. Defaults to <c>RxApp.MainThreadScheduler</c>.
            </param>
            <returns>
            The <c>ReactiveCommand</c> instance.
            </returns>
            <typeparam name="TParam">
            The type of the parameter passed through to command execution.
            </typeparam>
        </member>
        <member name="M:ReactiveUI.ReactiveCommand.CreateFromTask``1(System.Func{``0,System.Threading.CancellationToken,System.Threading.Tasks.Task},System.IObservable{System.Boolean},System.Reactive.Concurrency.IScheduler)">
            <summary>
            Creates a <see cref="T:ReactiveUI.ReactiveCommand`2"/> with asynchronous, cancellable execution logic that takes a parameter of type <typeparamref name="TParam"/>.
            </summary>
            <param name="execute">
            Provides a <see cref="T:System.Threading.Tasks.Task"/> representing the command's asynchronous execution logic.
            </param>
            <param name="canExecute">
            An optional observable that dictates the availability of the command for execution.
            </param>
            <param name="outputScheduler">
            An optional scheduler that is used to surface events. Defaults to <c>RxApp.MainThreadScheduler</c>.
            </param>
            <returns>
            The <c>ReactiveCommand</c> instance.
            </returns>
            <typeparam name="TParam">
            The type of the parameter passed through to command execution.
            </typeparam>
        </member>
        <member name="M:ReactiveUI.ReactiveCommand.CreateCombined``2(System.Collections.Generic.IEnumerable{ReactiveUI.ReactiveCommandBase{``0,``1}},System.IObservable{System.Boolean},System.Reactive.Concurrency.IScheduler)">
            <summary>
            Creates a <see cref="T:ReactiveUI.CombinedReactiveCommand`2"/> that composes all the provided child commands.
            </summary>
            <param name="childCommands">
            The child commands that the combined command will compose.
            </param>
            <param name="canExecute">
            An optional observable that dictates the availability of the command for execution (in addition to the availability specified
            by each individual child command).
            </param>
            <param name="outputScheduler">
            An optional scheduler that is used to surface events. Defaults to <c>RxApp.MainThreadScheduler</c>.
            </param>
            <returns>
            The <c>CombinedReactiveCommand</c> instance.
            </returns>
            <typeparam name="TParam">
            The type of the parameter passed through to command execution.
            </typeparam>
            <typeparam name="TResult">
            The type of the command's result.
            </typeparam>
        </member>
        <member name="P:ReactiveUI.ReactiveCommand.CanExecute">
            <summary>
            An observable whose value indicates whether the command can currently execute.
            </summary>
            <remarks>
            The value provided by this observable is governed both by any <c>canExecute</c> observable provided during
            command creation, as well as the current execution status of the command. A command that is currently executing
            will always yield <c>false</c> from this observable, even if the <c>canExecute</c> pipeline is currently <c>true</c>.
            </remarks>
        </member>
        <member name="P:ReactiveUI.ReactiveCommand.IsExecuting">
            <summary>
            An observable whose value indicates whether the command is currently executing.
            </summary>
            <remarks>
            This observable can be particularly useful for updating UI, such as showing an activity indicator whilst a command
            is executing.
            </remarks>
        </member>
        <member name="P:ReactiveUI.ReactiveCommand.ThrownExceptions">
            <summary>
            An observable that ticks any exceptions in command execution logic.
            </summary>
            <remarks>
            Any exceptions that are not observed via this observable will propagate out and cause the application to be torn
            down. Therefore, you will always want to subscribe to this observable if you expect errors could occur (e.g. if
            your command execution includes network activity).
            </remarks>
        </member>
        <member name="M:ReactiveUI.ReactiveCommand.Dispose">
            <summary>
            Disposes of this <c>ReactiveCommand</c>.
            </summary>
        </member>
        <member name="T:ReactiveUI.ReactiveCommandBase`2">
            <summary>
            A base class for generic reactive commands.
            </summary>
            <remarks>
            <para>
            This class extends <see cref="T:ReactiveUI.ReactiveCommand"/> and adds generic type parameters for the parameter values passed
            into command execution, and the return values of command execution.
            </para>
            <para>
            Because the result type is known by this class, it can implement <see cref="T:System.IObservable`1"/>. However, the implementation
            is defined as abstract, so subclasses must provide it.
            </para>
            </remarks>
            <typeparam name="TParam">
            The type of parameter values passed in during command execution.
            </typeparam>
            <typeparam name="TResult">
            The type of the values that are the result of command execution.
            </typeparam>
        </member>
        <member name="M:ReactiveUI.ReactiveCommandBase`2.Subscribe(System.IObserver{`1})">
            <summary>
            Subscribes to execution results from this command.
            </summary>
            <param name="observer">
            The observer.
            </param>
            <returns>
            An <see cref="T:System.IDisposable"/> that, when disposed, will unsubscribe the observer.
            </returns>
        </member>
        <member name="M:ReactiveUI.ReactiveCommandBase`2.Execute(`0)">
            <summary>
            Gets an observable that, when subscribed, executes this command.
            </summary>
            <remarks>
            <para>
            Invoking this method will return a cold (lazy) observable that, when subscribed, will execute the logic
            encapsulated by the command. It is worth restating that the returned observable is lazy. Nothing will
            happen if you call <c>Execute</c> and neglect to subscribe (directly or indirectly) to the returned observable.
            </para>
            <para>
            If no parameter value is provided, a default value of type <typeparamref name="TParam"/> will be passed into
            the execution logic.
            </para>
            <para>
            Any number of subscribers can subscribe to a given execution observable and the execution logic will only
            run once. That is, the result is broadcast to those subscribers.
            </para>
            <para>
            In those cases where execution fails, there will be no result value. Instead, the failure will tick through the
            <see cref="!:ThrownExceptions"/> observable.
            </para>
            </remarks>
            <param name="parameter">
            The parameter to pass into command execution.
            </param>
            <returns>
            An observable that will tick the single result value if and when it becomes available.
            </returns>
        </member>
        <member name="T:ReactiveUI.ReactiveCommand`2">
            <summary>
            Encapsulates a user interaction behind a reactive interface.
            </summary>
            <remarks>
            <para>
            This class provides the bulk of the actual implementation for reactive commands. You should not create instances
            of this class directly, but rather via the static creation methods on the non-generic <see cref="T:ReactiveUI.ReactiveCommand"/>
            class.
            </para>
            </remarks>
            <typeparam name="TParam">
            The type of parameter values passed in during command execution.
            </typeparam>
            <typeparam name="TResult">
            The type of the values that are the result of command execution.
            </typeparam>
        </member>
        <member name="P:ReactiveUI.ReactiveCommand`2.CanExecute">
            <inheritdoc/>
        </member>
        <member name="P:ReactiveUI.ReactiveCommand`2.IsExecuting">
            <inheritdoc/>
        </member>
        <member name="P:ReactiveUI.ReactiveCommand`2.ThrownExceptions">
            <inheritdoc/>
        </member>
        <member name="M:ReactiveUI.ReactiveCommand`2.Subscribe(System.IObserver{`1})">
            <inheritdoc/>
        </member>
        <member name="M:ReactiveUI.ReactiveCommand`2.Execute(`0)">
            <inheritdoc/>
        </member>
        <member name="T:ReactiveUI.CombinedReactiveCommand`2">
            <summary>
            Encapsulates a composite user interaction.
            </summary>
            <remarks>
            <para>
            This class provides the bulk of the actual implementation for combined reactive commands. You should not
            create instances of this class directly, but rather via the static creation methods on the non-generic
            <see cref="T:ReactiveUI.ReactiveCommand"/> class.
            </para>
            <para>
            A <c>CombinedReactiveCommand</c> combines multiple reactive commands into a single command. Executing
            the combined command executes all child commands. Since all child commands will receive the same execution
            parameter, all child commands must accept a parameter of the same type.
            </para>
            <para>
            In order for the combined command to be executable, all child commands must themselves be executable.
            In addition, any <c>canExecute</c> observable passed in during construction must also yield <c>true</c>.
            </para>
            </remarks>
            <typeparam name="TParam">
            The type of parameter values passed in during command execution.
            </typeparam>
            <typeparam name="TResult">
            The type of the values that are the result of command execution.
            </typeparam>
        </member>
        <member name="P:ReactiveUI.CombinedReactiveCommand`2.CanExecute">
            <inheritdoc/>
        </member>
        <member name="P:ReactiveUI.CombinedReactiveCommand`2.IsExecuting">
            <inheritdoc/>
        </member>
        <member name="P:ReactiveUI.CombinedReactiveCommand`2.ThrownExceptions">
            <inheritdoc/>
        </member>
        <member name="M:ReactiveUI.CombinedReactiveCommand`2.Subscribe(System.IObserver{System.Collections.Generic.IList{`1}})">
            <inheritdoc/>
        </member>
        <member name="M:ReactiveUI.CombinedReactiveCommand`2.Execute(`0)">
            <inheritdoc/>
        </member>
        <member name="M:ReactiveUI.ReactiveCommandMixins.InvokeCommand``1(System.IObservable{``0},System.Windows.Input.ICommand)">
            <summary>
            A utility method that will pipe an Observable to an ICommand (i.e.
            it will first call its CanExecute with the provided value, then if
            the command can be executed, Execute() will be called)
            </summary>
            <param name="command">The command to be executed.</param>
            <returns>An object that when disposes, disconnects the Observable
            from the command.</returns>
        </member>
        <member name="M:ReactiveUI.ReactiveCommandMixins.InvokeCommand``2(System.IObservable{``0},ReactiveUI.ReactiveCommandBase{``0,``1})">
            <summary>
            A utility method that will pipe an Observable to an ICommand (i.e.
            it will first call its CanExecute with the provided value, then if
            the command can be executed, Execute() will be called)
            </summary>
            <param name="command">The command to be executed.</param>
            <returns>An object that when disposes, disconnects the Observable
            from the command.</returns>
        </member>
        <member name="M:ReactiveUI.ReactiveCommandMixins.InvokeCommand``2(System.IObservable{``0},``1,System.Linq.Expressions.Expression{System.Func{``1,System.Windows.Input.ICommand}})">
            <summary>
            A utility method that will pipe an Observable to an ICommand (i.e.
            it will first call its CanExecute with the provided value, then if
            the command can be executed, Execute() will be called)
            </summary>
            <param name="target">The root object which has the Command.</param>
            <param name="commandProperty">The expression to reference the Command.</param>
            <returns>An object that when disposes, disconnects the Observable
            from the command.</returns>
        </member>
        <member name="M:ReactiveUI.ReactiveCommandMixins.InvokeCommand``3(System.IObservable{``0},``2,System.Linq.Expressions.Expression{System.Func{``2,ReactiveUI.ReactiveCommandBase{``0,``1}}})">
            <summary>
            A utility method that will pipe an Observable to an ICommand (i.e.
            it will first call its CanExecute with the provided value, then if
            the command can be executed, Execute() will be called)
            </summary>
            <param name="target">The root object which has the Command.</param>
            <param name="commandProperty">The expression to reference the Command.</param>
            <returns>An object that when disposes, disconnects the Observable
            from the command.</returns>
        </member>
        <member name="M:ReactiveUI.ReactiveNotifyPropertyChangedMixin.ObservableForProperty``2(``0,System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Boolean,System.Boolean)">
            <summary>
            ObservableForProperty returns an Observable representing the
            property change notifications for a specific property on a
            ReactiveObject. This method (unlike other Observables that return
            IObservedChange) guarantees that the Value property of
            the IObservedChange is set.
            </summary>
            <param name="property">An Expression representing the property (i.e.
            'x => x.SomeProperty.SomeOtherProperty'</param>
            <param name="beforeChange">If True, the Observable will notify
            immediately before a property is going to change.</param>
            <returns>An Observable representing the property change
            notifications for the given property.</returns>
        </member>
        <member name="M:ReactiveUI.ReactiveNotifyPropertyChangedMixin.ObservableForProperty``3(``0,System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Func{``1,``2},System.Boolean)">
            <summary>
            ObservableForProperty returns an Observable representing the
            property change notifications for a specific property on a
            ReactiveObject, running the IObservedChange through a Selector
            function.
            </summary>
            <param name="property">An Expression representing the property (i.e.
            'x => x.SomeProperty'</param>
            <param name="selector">A Select function that will be run on each
            item.</param>
            <param name="beforeChange">If True, the Observable will notify
            immediately before a property is going to change.</param>
            <returns>An Observable representing the property change
            notifications for the given property.</returns>
        </member>
        <member name="T:ReactiveUI.ReactiveObject">
            <summary>
            ReactiveObject is the base object for ViewModel classes, and it
            implements INotifyPropertyChanged. In addition, ReactiveObject provides
            Changing and Changed Observables to monitor object changes.
            </summary>
        </member>
        <member name="P:ReactiveUI.ReactiveObject.Changing">
            <summary>
            Represents an Observable that fires *before* a property is about to
            be changed.
            </summary>
        </member>
        <member name="P:ReactiveUI.ReactiveObject.Changed">
            <summary>
            Represents an Observable that fires *after* a property has changed.
            </summary>
        </member>
        <member name="P:ReactiveUI.ReactiveObject.ThrownExceptions">
             <summary>
            
             </summary>
        </member>
        <member name="M:ReactiveUI.ReactiveObject.SuppressChangeNotifications">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="M:ReactiveUI.ReactiveObject.AreChangeNotificationsEnabled">
             <summary>
            
             </summary>
             <returns></returns>
        </member>
        <member name="T:ReactiveUI.IMessageBus">
             <summary>
             IMessageBus represents an object that can act as a "Message Bus", a
             simple way for ViewModels and other objects to communicate with each
             other in a loosely coupled way.
            
             Specifying which messages go where is done via a combination of the Type
             of the message as well as an additional "Contract" parameter; this is a
             unique string used to distinguish between messages of the same Type, and
             is arbitrarily set by the client.
             </summary>
        </member>
        <member name="M:ReactiveUI.IMessageBus.RegisterScheduler``1(System.Reactive.Concurrency.IScheduler,System.String)">
            <summary>
            Registers a scheduler for the type, which may be specified at
            runtime, and the contract.
            </summary>
            <remarks>If a scheduler is already registered for the specified
            runtime and contract, this will overrwrite the existing
            registration.</remarks>
            <typeparam name="T">The type of the message to listen to.</typeparam>
            <param name="scheduler">The scheduler on which to post the
            notifications for the specified type and contract.
            CurrentThreadScheduler by default.</param>
            <param name="contract">A unique string to distinguish messages with
            identical types (i.e. "MyCoolViewModel") - if the message type is
            only used for one purpose, leave this as null.</param>
        </member>
        <member name="M:ReactiveUI.IMessageBus.Listen``1(System.String)">
            <summary>
            Listen provides an Observable that will fire whenever a Message is
            provided for this object via RegisterMessageSource or SendMessage.
            </summary>
            <typeparam name="T">The type of the message to listen to.</typeparam>
            <param name="contract">A unique string to distinguish messages with
            identical types (i.e. "MyCoolViewModel") - if the message type is
            only used for one purpose, leave this as null.</param>
            <returns></returns>
        </member>
        <member name="M:ReactiveUI.IMessageBus.ListenIncludeLatest``1(System.String)">
            <summary>
            ListenIncludeLatest provides an Observable that will fire whenever a Message is
            provided for this object via RegisterMessageSource or SendMessage and fire the
            last provided Message immediately if applicable, or null.
            </summary>
            <typeparam name="T">The type of the message to listen to.</typeparam>
            <param name="contract">A unique string to distinguish messages with
            identical types (i.e. "MyCoolViewModel") - if the message type is
            only used for one purpose, leave this as null.</param>
            <returns>An Observable representing the notifications posted to the
            message bus.</returns>
        </member>
        <member name="M:ReactiveUI.IMessageBus.IsRegistered(System.Type,System.String)">
            <summary>
            Determines if a particular message Type is registered.
            </summary>
            <param name="type">The type of the message.</param>
            <param name="contract">A unique string to distinguish messages with
            identical types (i.e. "MyCoolViewModel") - if the message type is
            only used for one purpose, leave this as null.</param>
            <returns>True if messages have been posted for this message Type.</returns>
        </member>
        <member name="M:ReactiveUI.IMessageBus.RegisterMessageSource``1(System.IObservable{``0},System.String)">
            <summary>
            Registers an Observable representing the stream of messages to send.
            Another part of the code can then call Listen to retrieve this
            Observable.
            </summary>
            <typeparam name="T">The type of the message to listen to.</typeparam>
            <param name="source">An Observable that will be subscribed to, and a
            message sent out for each value provided.</param>
            <param name="contract">A unique string to distinguish messages with
            identical types (i.e. "MyCoolViewModel") - if the message type is
            only used for one purpose, leave this as null.</param>
        </member>
        <member name="M:ReactiveUI.IMessageBus.SendMessage``1(``0,System.String)">
            <summary>
            Sends a single message using the specified Type and contract.
            Consider using RegisterMessageSource instead if you will be sending
            messages in response to other changes such as property changes
            or events.
            </summary>
            <typeparam name="T">The type of the message to send.</typeparam>
            <param name="message">The actual message to send</param>
            <param name="contract">A unique string to distinguish messages with
            identical types (i.e. "MyCoolViewModel") - if the message type is
            only used for one purpose, leave this as null.</param>
        </member>
        <member name="T:ReactiveUI.ICreatesObservableForProperty">
            <summary>
            ICreatesObservableForProperty represents an object that knows how to
            create notifications for a given type of object. Implement this if you
            are porting RxUI to a new UI toolkit, or generally want to enable WhenAny
            for another type of object that can be observed in a unique way.
            </summary>
        </member>
        <member name="M:ReactiveUI.ICreatesObservableForProperty.GetAffinityForObject(System.Type,System.String,System.Boolean)">
            <summary>
            Returns a positive integer when this class supports
            GetNotificationForProperty for this particular Type. If the method
            isn't supported at all, return a non-positive integer. When multiple
            implementations return a positive value, the host will use the one
            which returns the highest value. When in doubt, return '2' or '0'
            </summary>
            <param name="type">The type to query for.</param>
            <returns>A positive integer if GNFP is supported, zero or a negative
            value otherwise</returns>
        </member>
        <member name="M:ReactiveUI.ICreatesObservableForProperty.GetNotificationForProperty(System.Object,System.Linq.Expressions.Expression,System.Boolean)">
            <summary>
            Subscribe to notifications on the specified property, given an
            object and a property name.
            </summary>
            <param name="sender">The object to observe.</param>
            <param name="expression">The expression on the object to observe.
            This will be either a MemberExpression or an IndexExpression
            dependending on the property.
            </param>
            <param name="beforeChanged">If true, signal just before the
            property value actually changes. If false, signal after the
            property changes.</param>
            <returns>An IObservable which is signalled whenever the specified
            property on the object changes. If this cannot be done for a
            specified value of beforeChanged, return Observable.Never</returns>
        </member>
        <member name="T:ReactiveUI.IBindingTypeConverter">
            <summary>
            This interface is the extensible implementation of IValueConverters for
            Bind and OneWayBind. Implement this to teach Bind and OneWayBind how to
            convert between types.
            </summary>
        </member>
        <member name="M:ReactiveUI.IBindingTypeConverter.GetAffinityForObjects(System.Type,System.Type)">
            <summary>
            Returns a positive integer when this class supports
            TryConvert for this particular Type. If the method isn't supported at
            all, return a non-positive integer. When multiple implementations
            return a positive value, the host will use the one which returns
            the highest value. When in doubt, return '2' or '0'.
            </summary>
            <param name="fromType">The source type to convert from</param>
            <param name="toType">The target type to convert to</param>
            <returns>A positive integer if TryConvert is supported,
            zero or a negative value otherwise</returns>
        </member>
        <member name="M:ReactiveUI.IBindingTypeConverter.TryConvert(System.Object,System.Type,System.Object,System.Object@)">
            <summary>
            Convert a given object to the specified type.
            </summary>
            <param name="from">The object to convert.</param>
            <param name="toType">The type to coerce the object to.</param>
            <param name="conversionHint">An implementation-defined value,
            usually to specify things like locale awareness.</param>
            <returns>An object that is of the type 'to'</returns>
        </member>
        <member name="T:ReactiveUI.IPropertyBindingHook">
            <summary>
            Implement this as a way to intercept bindings at the time that they are
            created and execute an additional action (or to cancel the binding)
            </summary>
        </member>
        <member name="M:ReactiveUI.IPropertyBindingHook.ExecuteHook(System.Object,System.Object,System.Func{ReactiveUI.IObservedChange{System.Object,System.Object}[]},System.Func{ReactiveUI.IObservedChange{System.Object,System.Object}[]},ReactiveUI.BindingDirection)">
            <summary>
            Called when any binding is set up.
            </summary>
            <returns>If false, the binding is cancelled</returns>
            <param name="source">The source ViewModel</param>
            <param name="target">The target View (not the actual control)</param>
            <param name="getCurrentViewModelProperties">Get current view model properties.</param>
            <param name="getCurrentViewProperties">Get current view properties.</param>
            <param name="direction">The Binding direction.</param>
        </member>
        <member name="T:ReactiveUI.IActivatable">
            <summary>
            Use this Interface when you want to mark a control as recieving View
            Activation when it doesn't have a backing ViewModel.
            </summary>
        </member>
        <member name="T:ReactiveUI.IViewFor">
            <summary>
            This base class is mostly used by the Framework. Implement <see cref="T:ReactiveUI.IViewFor`1"/>
            instead.
            </summary>
        </member>
        <member name="P:ReactiveUI.IViewFor.ViewModel">
             <summary>
            
             </summary>
        </member>
        <member name="T:ReactiveUI.IViewFor`1">
            <summary>
            Implement this interface on your Views to support Routing and Binding.
            </summary>
        </member>
        <member name="P:ReactiveUI.IViewFor`1.ViewModel">
            <summary>
            The ViewModel corresponding to this specific View. This should be
            a DependencyProperty if you're using XAML.
            </summary>
        </member>
        <member name="T:ReactiveUI.IScreen">
            <summary>
            IScreen represents any object that is hosting its own routing -
            usually this object is your AppViewModel or MainWindow object.
            </summary>
        </member>
        <member name="P:ReactiveUI.IScreen.Router">
            <summary>
            The Router associated with this Screen.
            </summary>
        </member>
        <member name="M:ReactiveUI.ICreatesCommandBinding.GetAffinityForObject(System.Type,System.Boolean)">
            <summary>
            Returns a positive integer when this class supports
            BindCommandToObject for this particular Type. If the method
            isn't supported at all, return a non-positive integer. When multiple
            implementations return a positive value, the host will use the one
            which returns the highest value. When in doubt, return '2' or '0'
            </summary>
            <param name="type">The type to query for.</param>
            <param name="hasEventTarget">If true, the host intends to use a custom
            event target.</param>
            <returns>A positive integer if BCTO is supported, zero or a negative
            value otherwise</returns>
        </member>
        <member name="M:ReactiveUI.ICreatesCommandBinding.BindCommandToObject(System.Windows.Input.ICommand,System.Object,System.IObservable{System.Object})">
            <summary>
            Bind an ICommand to a UI object, in the "default" way. The meaning
            of this is dependent on the implementation. Implement this if you
            have a new type of UI control that doesn't have
            Command/CommandParameter like WPF or has a non-standard event name
            for "Invoke".
            </summary>
            <param name="command">The command to bind</param>
            <param name="target">The target object, usually a UI control of
            some kind</param>
            <param name="commandParameter">An IObservable source whose latest
            value will be passed as the command parameter to the command. Hosts
            will always pass a valid IObservable, but this may be
            Observable.Empty</param>
            <returns>An IDisposable which will disconnect the binding when
            disposed.</returns>
        </member>
        <member name="M:ReactiveUI.ICreatesCommandBinding.BindCommandToObject``1(System.Windows.Input.ICommand,System.Object,System.IObservable{System.Object},System.String)">
            <summary>
            Bind an ICommand to a UI object to a specific event. This event may
            be a standard .NET event, or it could be an event derived in another
            manner (i.e. in MonoTouch).
            </summary>
            <param name="command">The command to bind</param>
            <param name="target">The target object, usually a UI control of
            some kind</param>
            <param name="commandParameter">An IObservable source whose latest
            value will be passed as the command parameter to the command. Hosts
            will always pass a valid IObservable, but this may be
            Observable.Empty</param>
            <param name="eventName">The event to bind to.</param>
            <returns></returns>
            <returns>An IDisposable which will disconnect the binding when
            disposed.</returns>
        </member>
        <member name="T:ReactiveUI.IViewLocator">
            <summary>
            Implement this to override how RoutedViewHost and ViewModelViewHost
            map ViewModels to Views.
            </summary>
        </member>
        <member name="M:ReactiveUI.IViewLocator.ResolveView``1(``0,System.String)">
            <summary>
            Determines the view for an associated ViewModel
            </summary>
            <returns>The view, with the ViewModel property assigned to
            viewModel.</returns>
            <param name="viewModel">View model.</param>
            <param name="contract">Contract.</param>
        </member>
        <member name="T:ReactiveUI.IActivationForViewFetcher">
            <summary>
            Implement this interface to override how ReactiveUI determines when a
            View is activated or deactivated. This is usually only used when porting
            ReactiveUI to a new UI framework
            </summary>
        </member>
        <member name="T:ReactiveUI.ISuspensionHost">
            <summary>
            ISuspensionHost represents a standardized version of the events that the
            host operating system publishes. Subscribe to these events in order to
            handle app suspend / resume.
            </summary>
        </member>
        <member name="P:ReactiveUI.ISuspensionHost.IsLaunchingNew">
            <summary>
            Signals when the application is launching new. This can happen when
            an app has recently crashed, as well as the first time the app has
            been launched. Apps should create their state from scratch.
            </summary>
        </member>
        <member name="P:ReactiveUI.ISuspensionHost.IsResuming">
            <summary>
            Signals when the application is resuming from suspended state (i.e.
            it was previously running but its process was destroyed).
            </summary>
        </member>
        <member name="P:ReactiveUI.ISuspensionHost.IsUnpausing">
            <summary>
            Signals when the application is activated. Note that this may mean
            that your process was not actively running before this signal.
            </summary>
        </member>
        <member name="P:ReactiveUI.ISuspensionHost.ShouldPersistState">
            <summary>
            Signals when the application should persist its state to disk.
            </summary>
            <value>Returns an IDisposable that should be disposed once the
            application finishes persisting its state</value>
        </member>
        <member name="P:ReactiveUI.ISuspensionHost.ShouldInvalidateState">
            <summary>
            Signals that the saved application state should be deleted, this
            usually is called after an app has crashed
            </summary>
        </member>
        <member name="P:ReactiveUI.ISuspensionHost.CreateNewAppState">
            <summary>
            A method that can be used to create a new application state - usually
            this method just calls 'new' on an object.
            </summary>
        </member>
        <member name="P:ReactiveUI.ISuspensionHost.AppState">
            <summary>
            The current application state - get a typed version of this via 
            <see cref="M:ReactiveUI.SuspensionHostExtensions.GetAppState``1(ReactiveUI.ISuspensionHost)"/>.
            The "application state" is a notion entirely defined
            via the client application - the framework places no restrictions on
            the object other than it can be serialized.
            </summary>
        </member>
        <member name="T:ReactiveUI.ISuspensionDriver">
            <summary>
            ISuspensionDriver represents a class that can load/save state to persistent
            storage. Most platforms have a basic implementation of this class, but you
            probably want to write your own.
            </summary>
        </member>
        <member name="M:ReactiveUI.ISuspensionDriver.LoadState">
            <summary>
            Loads the application state from persistent storage
            </summary>
        </member>
        <member name="M:ReactiveUI.ISuspensionDriver.SaveState(System.Object)">
            <summary>
            Saves the application state to disk.
            </summary>
        </member>
        <member name="M:ReactiveUI.ISuspensionDriver.InvalidateState">
            <summary>
            Invalidates the application state (i.e. deletes it from disk)
            </summary>
        </member>
        <member name="M:ReactiveUI.RoutableViewModelMixin.WhenNavigatedTo(ReactiveUI.IRoutableViewModel,System.Func{System.IDisposable})">
            <summary>
            This method allows you to set up connections that only operate
            while the ViewModel has focus, and cleans up when the ViewModel
            loses focus.
            </summary>
            <param name="onNavigatedTo">Called when the ViewModel is navigated
            to - return an IDisposable that cleans up all of the things that are
            configured in the method.</param>
            <returns>An IDisposable that lets you disconnect the entire process
            earlier than normal.</returns>
        </member>
        <member name="M:ReactiveUI.RoutableViewModelMixin.WhenNavigatedToObservable(ReactiveUI.IRoutableViewModel)">
            <summary>
            This method will return an observable that fires events every time
            the topmost ViewModel in the navigation stack is this ViewModel.
            This allows you to set up connections that only operate while the
            ViewModel has focus.
            
            The observable will complete when the ViewModel is removed completely
            from the navigation stack. If your ViewModel can be _removed_ from
            the navigation stack and then reused later, you must call this method
            and resubscribe each time it is reused.
            </summary>
            <returns>An IObservable{Unit} that signals when the ViewModel has
            been added or brought to the top of the navigation stack. The
            observable completes when the ViewModel is no longer a part of the
            navigation stack.</returns>
        </member>
        <member name="M:ReactiveUI.RoutableViewModelMixin.WhenNavigatingFromObservable(ReactiveUI.IRoutableViewModel)">
            <summary>
            This method will return an observable that fires events _just before_
            the ViewModel is no longer the topmost ViewModel in the navigation
            stack. This allows you to clean up anything before losing focus.
            
            The observable will complete when the ViewModel is removed completely
            from the navigation stack. If your ViewModel can be _removed_ from
            the navigation stack and then reused later, you must call this method
            and resubscribe each time it is reused.
            </summary>
            <returns>An IObservable{Unit} that signals when the ViewModel is no
            longer the topmost ViewModel in the navigation stack. The observable
            completes when the ViewModel is no longer a part of the navigation
            stack.</returns>
        </member>
        <member name="T:ReactiveUI.RoutingState">
            <summary>
            RoutingState manages the ViewModel Stack and allows ViewModels to
            navigate to other ViewModels.
            </summary>
        </member>
        <member name="P:ReactiveUI.RoutingState.NavigationStack">
            <summary>
            Represents the current navigation stack, the last element in the
            collection being the currently visible ViewModel.
            </summary>
        </member>
        <member name="P:ReactiveUI.RoutingState.Scheduler">
            <summary>
            The scheduler used for commands. Defaults to <c>RxApp.MainThreadScheduler</c>.
            </summary>
        </member>
        <member name="P:ReactiveUI.RoutingState.NavigateBack">
            <summary>
            Navigates back to the previous element in the stack.
            </summary>
        </member>
        <member name="P:ReactiveUI.RoutingState.Navigate">
            <summary>
            Navigates to the a new element in the stack - the Execute parameter
            must be a ViewModel that implements IRoutableViewModel.
            </summary>
        </member>
        <member name="P:ReactiveUI.RoutingState.NavigateAndReset">
            <summary>
            Navigates to a new element and resets the navigation stack (i.e. the
            new ViewModel will now be the only element in the stack) - the
            Execute parameter must be a ViewModel that implements
            IRoutableViewModel.
            </summary>
        </member>
        <member name="M:ReactiveUI.RoutingStateMixins.FindViewModelInStack``1(ReactiveUI.RoutingState)">
            <summary>
            Locate the first ViewModel in the stack that matches a certain Type.
            </summary>
            <returns>The matching ViewModel or null if none exists.</returns>
        </member>
        <member name="M:ReactiveUI.RoutingStateMixins.GetCurrentViewModel(ReactiveUI.RoutingState)">
            <summary>
            Returns the currently visible ViewModel
            </summary>
        </member>
        <member name="P:ReactiveUI.RxApp.MainThreadScheduler">
            <summary>
            MainThreadScheduler is the scheduler used to schedule work items that
            should be run "on the UI thread". In normal mode, this will be
            DispatcherScheduler, and in Unit Test mode this will be Immediate,
            to simplify writing common unit tests.
            </summary>
        </member>
        <member name="P:ReactiveUI.RxApp.TaskpoolScheduler">
            <summary>
            TaskpoolScheduler is the scheduler used to schedule work items to
            run in a background thread. In both modes, this will run on the TPL
            Task Pool (or the normal Threadpool on Silverlight).
            </summary>
        </member>
        <member name="P:ReactiveUI.RxApp.DefaultExceptionHandler">
            <summary>
            This Observer is signalled whenever an object that has a
            ThrownExceptions property doesn't Subscribe to that Observable. Use
            Observer.Create to set up what will happen - the default is to crash
            the application with an error message.
            </summary>
        </member>
        <member name="P:ReactiveUI.RxApp.SuspensionHost">
            <summary>
            This returns / allows you to override the current SuspensionHost, a
            class which provides events for process lifetime events, especially
            on mobile devices.
            </summary>
        </member>
        <member name="P:ReactiveUI.RxApp.SupportsRangeNotifications">
            <summary>
            Returns whether your UI framework is brain-dead or not and will blow
            up if a INotifyCollectionChanged object returns a ranged Add
            </summary>
        </member>
        <member name="T:ReactiveUI.UnhandledErrorException">
            <summary>
            Indicates that an object implementing <see cref="T:ReactiveUI.IHandleObservableErrors"/> has errored and nothing is attached
            to <see cref="P:ReactiveUI.IHandleObservableErrors.ThrownExceptions"/> to handle that error.
            </summary>
        </member>
        <member name="M:ReactiveUI.UnhandledErrorException.#ctor">
            <summary>
            Creates a new instance of <c>UnhandledErrorException</c>.
            </summary>
        </member>
        <member name="M:ReactiveUI.UnhandledErrorException.#ctor(System.String)">
            <summary>
            Creates a new instance of <c>UnhandledErrorException</c>.
            </summary>
            <param name="message">
            The exception message.
            </param>
        </member>
        <member name="M:ReactiveUI.UnhandledErrorException.#ctor(System.String,System.Exception)">
            <summary>
            Creates a new instance of <c>UnhandledErrorException</c>.
            </summary>
            <param name="message">
            The exception message.
            </param>
            <param name="innerException">
            The exception that caused this exception.
            </param>
        </member>
        <member name="P:ReactiveUI.DefaultViewLocator.ViewModelToViewFunc">
            <summary>
            Gets or sets a function that is used to convert a view model name to a proposed view name.
            </summary>
            <remarks>
            <para>
            If unset, the default behavior is to change "ViewModel" to "View". If a different convention is followed, assign an appropriate function to this
            property.
            </para>
            <para>
            Note that the name returned by the function is a starting point for view resolution. Variants on the name will be resolved according to the rules
            set out by the <see cref="M:ReactiveUI.DefaultViewLocator.ResolveView``1(``0,System.String)"/> method.
            </para>
            </remarks>
        </member>
        <member name="M:ReactiveUI.DefaultViewLocator.ResolveView``1(``0,System.String)">
            <summary>
            Returns the view associated with a view model, deriving the name of the type via <see cref="P:ReactiveUI.DefaultViewLocator.ViewModelToViewFunc"/>, then discovering it via the
            service locator.
            </summary>
            <remarks>
            <para>
            Given view model type <c>T</c> with runtime type <c>RT</c>, this implementation will attempt to resolve the following views:
            <list type="number">
            <item>
            <description>
            Look for a service registered under the type whose name is given to us by passing <c>RT</c> to <see cref="P:ReactiveUI.DefaultViewLocator.ViewModelToViewFunc"/> (which defaults to changing "ViewModel" to "View").
            </description>
            </item>
            <item>
            <description>
            Look for a service registered under the type <c>IViewFor&lt;RT&gt;</c>.
            </description>
            </item>
            <item>
            <description>
            Look for a service registered under the type whose name is given to us by passing <c>T</c> to <see cref="P:ReactiveUI.DefaultViewLocator.ViewModelToViewFunc"/> (which defaults to changing "ViewModel" to "View").
            </description>
            </item>
            <item>
            <description>
            Look for a service registered under the type <c>IViewFor&lt;T&gt;</c>.
            </description>
            </item>
            <item>
            <description>
            If <c>T</c> is an interface, change its name to that of a class (i.e. drop the leading "I"). If it's a class, change to an interface (i.e. add a leading "I").
            </description>
            </item>
            <item>
            <description>
            Repeat steps 1-4 with the type resolved from the modified name.
            </description>
            </item>
            </list>
            </para>
            </remarks>
            <param name="viewModel">
            The view model whose associated view is to be resolved.
            </param>
            <param name="contract">
            Optional contract to be used when resolving from Splat
            </param>
            <returns>
            The view associated with the given view model.
            </returns>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyValue``2(``0,System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            WhenAnyValue allows you to observe whenever the value of a
            property on an object has changed, providing an initial value when
            the Observable is set up, unlike ObservableForProperty(). Use this
            method in constructors to set up bindings between properties that also
            need an initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyValue``3(``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Func{``2,``1})">
            <summary>
            WhenAnyValue allows you to observe whenever the value of one or more
            properties on an object have changed, providing an initial value when
            the Observable is set up, unlike ObservableForProperty(). Use this
            method in constructors to set up bindings between properties that also
            need an initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAny``3(``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Func{ReactiveUI.IObservedChange{``0,``2},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyDynamic``2(``0,System.Linq.Expressions.Expression,System.Func{ReactiveUI.IObservedChange{``0,System.Object},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyValue``3(``0,System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``0,``2}})">
            <summary>
            WhenAnyValue allows you to observe whenever the value of one or more
            properties on an object have changed, providing an initial value when
            the Observable is set up, unlike ObservableForProperty(). Use this
            method in constructors to set up bindings between properties that also
            need an initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyValue``4(``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Func{``2,``3,``1})">
            <summary>
            WhenAnyValue allows you to observe whenever the value of one or more
            properties on an object have changed, providing an initial value when
            the Observable is set up, unlike ObservableForProperty(). Use this
            method in constructors to set up bindings between properties that also
            need an initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAny``4(``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Func{ReactiveUI.IObservedChange{``0,``2},ReactiveUI.IObservedChange{``0,``3},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyDynamic``2(``0,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Func{ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyValue``4(``0,System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}})">
            <summary>
            WhenAnyValue allows you to observe whenever the value of one or more
            properties on an object have changed, providing an initial value when
            the Observable is set up, unlike ObservableForProperty(). Use this
            method in constructors to set up bindings between properties that also
            need an initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyValue``5(``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``0,``4}},System.Func{``2,``3,``4,``1})">
            <summary>
            WhenAnyValue allows you to observe whenever the value of one or more
            properties on an object have changed, providing an initial value when
            the Observable is set up, unlike ObservableForProperty(). Use this
            method in constructors to set up bindings between properties that also
            need an initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAny``5(``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``0,``4}},System.Func{ReactiveUI.IObservedChange{``0,``2},ReactiveUI.IObservedChange{``0,``3},ReactiveUI.IObservedChange{``0,``4},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyDynamic``2(``0,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Func{ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyValue``5(``0,System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``0,``4}})">
            <summary>
            WhenAnyValue allows you to observe whenever the value of one or more
            properties on an object have changed, providing an initial value when
            the Observable is set up, unlike ObservableForProperty(). Use this
            method in constructors to set up bindings between properties that also
            need an initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyValue``6(``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``0,``4}},System.Linq.Expressions.Expression{System.Func{``0,``5}},System.Func{``2,``3,``4,``5,``1})">
            <summary>
            WhenAnyValue allows you to observe whenever the value of one or more
            properties on an object have changed, providing an initial value when
            the Observable is set up, unlike ObservableForProperty(). Use this
            method in constructors to set up bindings between properties that also
            need an initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAny``6(``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``0,``4}},System.Linq.Expressions.Expression{System.Func{``0,``5}},System.Func{ReactiveUI.IObservedChange{``0,``2},ReactiveUI.IObservedChange{``0,``3},ReactiveUI.IObservedChange{``0,``4},ReactiveUI.IObservedChange{``0,``5},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyDynamic``2(``0,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Func{ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyValue``6(``0,System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``0,``4}},System.Linq.Expressions.Expression{System.Func{``0,``5}})">
            <summary>
            WhenAnyValue allows you to observe whenever the value of one or more
            properties on an object have changed, providing an initial value when
            the Observable is set up, unlike ObservableForProperty(). Use this
            method in constructors to set up bindings between properties that also
            need an initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyValue``7(``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``0,``4}},System.Linq.Expressions.Expression{System.Func{``0,``5}},System.Linq.Expressions.Expression{System.Func{``0,``6}},System.Func{``2,``3,``4,``5,``6,``1})">
            <summary>
            WhenAnyValue allows you to observe whenever the value of one or more
            properties on an object have changed, providing an initial value when
            the Observable is set up, unlike ObservableForProperty(). Use this
            method in constructors to set up bindings between properties that also
            need an initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAny``7(``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``0,``4}},System.Linq.Expressions.Expression{System.Func{``0,``5}},System.Linq.Expressions.Expression{System.Func{``0,``6}},System.Func{ReactiveUI.IObservedChange{``0,``2},ReactiveUI.IObservedChange{``0,``3},ReactiveUI.IObservedChange{``0,``4},ReactiveUI.IObservedChange{``0,``5},ReactiveUI.IObservedChange{``0,``6},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyDynamic``2(``0,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Func{ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyValue``7(``0,System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``0,``4}},System.Linq.Expressions.Expression{System.Func{``0,``5}},System.Linq.Expressions.Expression{System.Func{``0,``6}})">
            <summary>
            WhenAnyValue allows you to observe whenever the value of one or more
            properties on an object have changed, providing an initial value when
            the Observable is set up, unlike ObservableForProperty(). Use this
            method in constructors to set up bindings between properties that also
            need an initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyValue``8(``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``0,``4}},System.Linq.Expressions.Expression{System.Func{``0,``5}},System.Linq.Expressions.Expression{System.Func{``0,``6}},System.Linq.Expressions.Expression{System.Func{``0,``7}},System.Func{``2,``3,``4,``5,``6,``7,``1})">
            <summary>
            WhenAnyValue allows you to observe whenever the value of one or more
            properties on an object have changed, providing an initial value when
            the Observable is set up, unlike ObservableForProperty(). Use this
            method in constructors to set up bindings between properties that also
            need an initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAny``8(``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``0,``4}},System.Linq.Expressions.Expression{System.Func{``0,``5}},System.Linq.Expressions.Expression{System.Func{``0,``6}},System.Linq.Expressions.Expression{System.Func{``0,``7}},System.Func{ReactiveUI.IObservedChange{``0,``2},ReactiveUI.IObservedChange{``0,``3},ReactiveUI.IObservedChange{``0,``4},ReactiveUI.IObservedChange{``0,``5},ReactiveUI.IObservedChange{``0,``6},ReactiveUI.IObservedChange{``0,``7},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyDynamic``2(``0,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Func{ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyValue``8(``0,System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``0,``4}},System.Linq.Expressions.Expression{System.Func{``0,``5}},System.Linq.Expressions.Expression{System.Func{``0,``6}},System.Linq.Expressions.Expression{System.Func{``0,``7}})">
            <summary>
            WhenAnyValue allows you to observe whenever the value of one or more
            properties on an object have changed, providing an initial value when
            the Observable is set up, unlike ObservableForProperty(). Use this
            method in constructors to set up bindings between properties that also
            need an initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyValue``9(``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``0,``4}},System.Linq.Expressions.Expression{System.Func{``0,``5}},System.Linq.Expressions.Expression{System.Func{``0,``6}},System.Linq.Expressions.Expression{System.Func{``0,``7}},System.Linq.Expressions.Expression{System.Func{``0,``8}},System.Func{``2,``3,``4,``5,``6,``7,``8,``1})">
            <summary>
            WhenAnyValue allows you to observe whenever the value of one or more
            properties on an object have changed, providing an initial value when
            the Observable is set up, unlike ObservableForProperty(). Use this
            method in constructors to set up bindings between properties that also
            need an initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAny``9(``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``0,``4}},System.Linq.Expressions.Expression{System.Func{``0,``5}},System.Linq.Expressions.Expression{System.Func{``0,``6}},System.Linq.Expressions.Expression{System.Func{``0,``7}},System.Linq.Expressions.Expression{System.Func{``0,``8}},System.Func{ReactiveUI.IObservedChange{``0,``2},ReactiveUI.IObservedChange{``0,``3},ReactiveUI.IObservedChange{``0,``4},ReactiveUI.IObservedChange{``0,``5},ReactiveUI.IObservedChange{``0,``6},ReactiveUI.IObservedChange{``0,``7},ReactiveUI.IObservedChange{``0,``8},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyDynamic``2(``0,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Func{ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyValue``10(``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``0,``4}},System.Linq.Expressions.Expression{System.Func{``0,``5}},System.Linq.Expressions.Expression{System.Func{``0,``6}},System.Linq.Expressions.Expression{System.Func{``0,``7}},System.Linq.Expressions.Expression{System.Func{``0,``8}},System.Linq.Expressions.Expression{System.Func{``0,``9}},System.Func{``2,``3,``4,``5,``6,``7,``8,``9,``1})">
            <summary>
            WhenAnyValue allows you to observe whenever the value of one or more
            properties on an object have changed, providing an initial value when
            the Observable is set up, unlike ObservableForProperty(). Use this
            method in constructors to set up bindings between properties that also
            need an initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAny``10(``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``0,``4}},System.Linq.Expressions.Expression{System.Func{``0,``5}},System.Linq.Expressions.Expression{System.Func{``0,``6}},System.Linq.Expressions.Expression{System.Func{``0,``7}},System.Linq.Expressions.Expression{System.Func{``0,``8}},System.Linq.Expressions.Expression{System.Func{``0,``9}},System.Func{ReactiveUI.IObservedChange{``0,``2},ReactiveUI.IObservedChange{``0,``3},ReactiveUI.IObservedChange{``0,``4},ReactiveUI.IObservedChange{``0,``5},ReactiveUI.IObservedChange{``0,``6},ReactiveUI.IObservedChange{``0,``7},ReactiveUI.IObservedChange{``0,``8},ReactiveUI.IObservedChange{``0,``9},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyDynamic``2(``0,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Func{ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyValue``11(``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``0,``4}},System.Linq.Expressions.Expression{System.Func{``0,``5}},System.Linq.Expressions.Expression{System.Func{``0,``6}},System.Linq.Expressions.Expression{System.Func{``0,``7}},System.Linq.Expressions.Expression{System.Func{``0,``8}},System.Linq.Expressions.Expression{System.Func{``0,``9}},System.Linq.Expressions.Expression{System.Func{``0,``10}},System.Func{``2,``3,``4,``5,``6,``7,``8,``9,``10,``1})">
            <summary>
            WhenAnyValue allows you to observe whenever the value of one or more
            properties on an object have changed, providing an initial value when
            the Observable is set up, unlike ObservableForProperty(). Use this
            method in constructors to set up bindings between properties that also
            need an initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAny``11(``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``0,``4}},System.Linq.Expressions.Expression{System.Func{``0,``5}},System.Linq.Expressions.Expression{System.Func{``0,``6}},System.Linq.Expressions.Expression{System.Func{``0,``7}},System.Linq.Expressions.Expression{System.Func{``0,``8}},System.Linq.Expressions.Expression{System.Func{``0,``9}},System.Linq.Expressions.Expression{System.Func{``0,``10}},System.Func{ReactiveUI.IObservedChange{``0,``2},ReactiveUI.IObservedChange{``0,``3},ReactiveUI.IObservedChange{``0,``4},ReactiveUI.IObservedChange{``0,``5},ReactiveUI.IObservedChange{``0,``6},ReactiveUI.IObservedChange{``0,``7},ReactiveUI.IObservedChange{``0,``8},ReactiveUI.IObservedChange{``0,``9},ReactiveUI.IObservedChange{``0,``10},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyDynamic``2(``0,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Func{ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyValue``12(``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``0,``4}},System.Linq.Expressions.Expression{System.Func{``0,``5}},System.Linq.Expressions.Expression{System.Func{``0,``6}},System.Linq.Expressions.Expression{System.Func{``0,``7}},System.Linq.Expressions.Expression{System.Func{``0,``8}},System.Linq.Expressions.Expression{System.Func{``0,``9}},System.Linq.Expressions.Expression{System.Func{``0,``10}},System.Linq.Expressions.Expression{System.Func{``0,``11}},System.Func{``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``1})">
            <summary>
            WhenAnyValue allows you to observe whenever the value of one or more
            properties on an object have changed, providing an initial value when
            the Observable is set up, unlike ObservableForProperty(). Use this
            method in constructors to set up bindings between properties that also
            need an initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAny``12(``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``0,``4}},System.Linq.Expressions.Expression{System.Func{``0,``5}},System.Linq.Expressions.Expression{System.Func{``0,``6}},System.Linq.Expressions.Expression{System.Func{``0,``7}},System.Linq.Expressions.Expression{System.Func{``0,``8}},System.Linq.Expressions.Expression{System.Func{``0,``9}},System.Linq.Expressions.Expression{System.Func{``0,``10}},System.Linq.Expressions.Expression{System.Func{``0,``11}},System.Func{ReactiveUI.IObservedChange{``0,``2},ReactiveUI.IObservedChange{``0,``3},ReactiveUI.IObservedChange{``0,``4},ReactiveUI.IObservedChange{``0,``5},ReactiveUI.IObservedChange{``0,``6},ReactiveUI.IObservedChange{``0,``7},ReactiveUI.IObservedChange{``0,``8},ReactiveUI.IObservedChange{``0,``9},ReactiveUI.IObservedChange{``0,``10},ReactiveUI.IObservedChange{``0,``11},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyDynamic``2(``0,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Func{ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyValue``13(``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``0,``4}},System.Linq.Expressions.Expression{System.Func{``0,``5}},System.Linq.Expressions.Expression{System.Func{``0,``6}},System.Linq.Expressions.Expression{System.Func{``0,``7}},System.Linq.Expressions.Expression{System.Func{``0,``8}},System.Linq.Expressions.Expression{System.Func{``0,``9}},System.Linq.Expressions.Expression{System.Func{``0,``10}},System.Linq.Expressions.Expression{System.Func{``0,``11}},System.Linq.Expressions.Expression{System.Func{``0,``12}},System.Func{``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``1})">
            <summary>
            WhenAnyValue allows you to observe whenever the value of one or more
            properties on an object have changed, providing an initial value when
            the Observable is set up, unlike ObservableForProperty(). Use this
            method in constructors to set up bindings between properties that also
            need an initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAny``13(``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``0,``4}},System.Linq.Expressions.Expression{System.Func{``0,``5}},System.Linq.Expressions.Expression{System.Func{``0,``6}},System.Linq.Expressions.Expression{System.Func{``0,``7}},System.Linq.Expressions.Expression{System.Func{``0,``8}},System.Linq.Expressions.Expression{System.Func{``0,``9}},System.Linq.Expressions.Expression{System.Func{``0,``10}},System.Linq.Expressions.Expression{System.Func{``0,``11}},System.Linq.Expressions.Expression{System.Func{``0,``12}},System.Func{ReactiveUI.IObservedChange{``0,``2},ReactiveUI.IObservedChange{``0,``3},ReactiveUI.IObservedChange{``0,``4},ReactiveUI.IObservedChange{``0,``5},ReactiveUI.IObservedChange{``0,``6},ReactiveUI.IObservedChange{``0,``7},ReactiveUI.IObservedChange{``0,``8},ReactiveUI.IObservedChange{``0,``9},ReactiveUI.IObservedChange{``0,``10},ReactiveUI.IObservedChange{``0,``11},ReactiveUI.IObservedChange{``0,``12},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyDynamic``2(``0,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Func{ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyValue``14(``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``0,``4}},System.Linq.Expressions.Expression{System.Func{``0,``5}},System.Linq.Expressions.Expression{System.Func{``0,``6}},System.Linq.Expressions.Expression{System.Func{``0,``7}},System.Linq.Expressions.Expression{System.Func{``0,``8}},System.Linq.Expressions.Expression{System.Func{``0,``9}},System.Linq.Expressions.Expression{System.Func{``0,``10}},System.Linq.Expressions.Expression{System.Func{``0,``11}},System.Linq.Expressions.Expression{System.Func{``0,``12}},System.Linq.Expressions.Expression{System.Func{``0,``13}},System.Func{``2,``3,``4,``5,``6,``7,``8,``9,``10,``11,``12,``13,``1})">
            <summary>
            WhenAnyValue allows you to observe whenever the value of one or more
            properties on an object have changed, providing an initial value when
            the Observable is set up, unlike ObservableForProperty(). Use this
            method in constructors to set up bindings between properties that also
            need an initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAny``14(``0,System.Linq.Expressions.Expression{System.Func{``0,``2}},System.Linq.Expressions.Expression{System.Func{``0,``3}},System.Linq.Expressions.Expression{System.Func{``0,``4}},System.Linq.Expressions.Expression{System.Func{``0,``5}},System.Linq.Expressions.Expression{System.Func{``0,``6}},System.Linq.Expressions.Expression{System.Func{``0,``7}},System.Linq.Expressions.Expression{System.Func{``0,``8}},System.Linq.Expressions.Expression{System.Func{``0,``9}},System.Linq.Expressions.Expression{System.Func{``0,``10}},System.Linq.Expressions.Expression{System.Func{``0,``11}},System.Linq.Expressions.Expression{System.Func{``0,``12}},System.Linq.Expressions.Expression{System.Func{``0,``13}},System.Func{ReactiveUI.IObservedChange{``0,``2},ReactiveUI.IObservedChange{``0,``3},ReactiveUI.IObservedChange{``0,``4},ReactiveUI.IObservedChange{``0,``5},ReactiveUI.IObservedChange{``0,``6},ReactiveUI.IObservedChange{``0,``7},ReactiveUI.IObservedChange{``0,``8},ReactiveUI.IObservedChange{``0,``9},ReactiveUI.IObservedChange{``0,``10},ReactiveUI.IObservedChange{``0,``11},ReactiveUI.IObservedChange{``0,``12},ReactiveUI.IObservedChange{``0,``13},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="M:ReactiveUI.WhenAnyMixin.WhenAnyDynamic``2(``0,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Func{ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},ReactiveUI.IObservedChange{``0,System.Object},``1})">
            <summary>
            WhenAny allows you to observe whenever one or more properties on an
            object have changed, providing an initial value when the Observable
            is set up, unlike ObservableForProperty(). Use this method in
            constructors to set up bindings between properties that also need an
            initial setup.
            </summary>
        </member>
        <member name="T:ReactiveUI.WaitForDispatcherScheduler">
            <summary>
            This scheduler attempts to deal with some of the brain-dead defaults
            on certain Microsoft platforms that make it difficult to access the
            Dispatcher during startup. This class wraps a scheduler and if it
            isn't available yet, it simply runs the scheduled item immediately.
            </summary>
        </member>
        <member name="M:ReactiveUI.ObservableLoggingMixin.Log``2(System.IObservable{``0},``1,System.String,System.Func{``0,System.String})">
            <summary>
            Logs an Observable to Splat's Logger
            </summary>
            <param name="klass">The hosting class, usually 'this'</param>
            <param name="message">An optional method</param>
            <param name="stringifier">An optional Func to convert Ts to strings.</param>
            <returns>The same Observable</returns>
        </member>
        <member name="M:ReactiveUI.ObservableLoggingMixin.LoggedCatch``2(System.IObservable{``0},``1,System.IObservable{``0},System.String)">
            <summary>
            Like Catch, but also prints a message and the error to the log.
            </summary>
            <param name="klass">The hosting class, usually 'this'</param>
            <param name="next">The Observable to replace the current one OnError.</param>
            <param name="message">An error message to print.</param>
            <returns>The same Observable</returns>
        </member>
        <member name="M:ReactiveUI.ObservableLoggingMixin.LoggedCatch``3(System.IObservable{``0},``1,System.Func{``2,System.IObservable{``0}},System.String)">
            <summary>
            Like Catch, but also prints a message and the error to the log.
            </summary>
            <param name="klass">The hosting class, usually 'this'</param>
            <param name="next">A Func to create an Observable to replace the
            current one OnError.</param>
            <param name="message">An error message to print.</param>
            <returns>The same Observable</returns>
        </member>
        <member name="M:ReactiveUI.IReactiveObjectExtensions.RaiseAndSetIfChanged``2(``0,``1@,``1,System.String)">
            <summary>
            RaiseAndSetIfChanged fully implements a Setter for a read-write
            property on a ReactiveObject, using CallerMemberName to raise the notification
            and the ref to the backing field to set the property.
            </summary>
            <typeparam name="TObj">The type of the This.</typeparam>
            <typeparam name="TRet">The type of the return value.</typeparam>
            <param name="This">The <see cref="T:ReactiveUI.ReactiveObject"/> raising the notification.</param>
            <param name="backingField">A Reference to the backing field for this
            property.</param>
            <param name="newValue">The new value.</param>
            <param name="propertyName">The name of the property, usually 
            automatically provided through the CallerMemberName attribute.</param>
            <returns>The newly set value, normally discarded.</returns>
        </member>
        <member name="M:ReactiveUI.IReactiveObjectExtensions.RaisePropertyChanged``1(``0,System.String)">
            <summary>
            Use this method in your ReactiveObject classes when creating custom
            properties where raiseAndSetIfChanged doesn't suffice.
            </summary>
            <param name="This">The instance of ReactiveObject on which the property has changed.</param>
            <param name="propertyName">
            A string representing the name of the property that has been changed.
            Leave <c>null</c> to let the runtime set to caller member name.
            </param>
        </member>
        <member name="M:ReactiveUI.IReactiveObjectExtensions.RaisePropertyChanging``1(``0,System.String)">
            <summary>
            Use this method in your ReactiveObject classes when creating custom
            properties where raiseAndSetIfChanged doesn't suffice.
            </summary>
            <param name="This">The instance of ReactiveObject on which the property has changed.</param>
            <param name="propertyName">
            A string representing the name of the property that has been changed.
            Leave <c>null</c> to let the runtime set to caller member name.
            </param>
        </member>
        <member name="M:ReactiveUI.IReactiveObjectExtensions.ExtensionState`1.#ctor(`0)">
            <summary>
            Initializes a new instance of the <see cref="T:ReactiveUI.IReactiveObjectExtensions.ExtensionState`1"/> class.
            </summary>
        </member>
        <member name="M:ReactiveUI.IReactiveObjectExtensions.ExtensionState`1.suppressChangeNotifications">
            <summary>
            When this method is called, an object will not fire change
            notifications (neither traditional nor Observable notifications)
            until the return value is disposed.
            </summary>
            <returns>An object that, when disposed, reenables change
            notifications.</returns>
        </member>
        <member name="T:ReactiveUI.WeakEventManager`3">
            <summary>
            WeakEventManager base class. Inspired by the WPF WeakEventManager class and the code in 
            http://social.msdn.microsoft.com/Forums/silverlight/en-US/34d85c3f-52ea-4adc-bb32-8297f5549042/command-binding-memory-leak?forum=silverlightbugs
            </summary>
            <typeparam name="TEventSource">The type of the event source.</typeparam>
            <typeparam name="TEventHandler">The type of the event handler.</typeparam>
            <typeparam name="TEventArgs">The type of the event arguments.</typeparam>
        </member>
        <member name="F:ReactiveUI.WeakEventManager`3.targetToEventHandler">
            <summary>
            Mapping between the target of the delegate (for example a Button) and the handler (EventHandler).
            Windows Phone needs this, otherwise the event handler gets garbage collected.
            </summary>
        </member>
        <member name="F:ReactiveUI.WeakEventManager`3.sourceToWeakHandlers">
            <summary>
            Mapping from the source of the event to the list of handlers. This is a CWT to ensure it does not leak the source of the event.
            </summary>
        </member>
        <member name="M:ReactiveUI.WeakEventManager`3.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:ReactiveUI.WeakEventManager`3"/> class.
            Protected to disallow instances of this class and force a subclass.
            </summary>
        </member>
        <member name="M:ReactiveUI.WeakEventManager`3.AddHandler(`0,`1)">
            <summary>
            Adds a weak reference to the handler and associates it with the source.
            </summary>
            <param name="source">The source.</param>
            <param name="handler">The handler.</param>
        </member>
        <member name="M:ReactiveUI.WeakEventManager`3.RemoveHandler(`0,`1)">
            <summary>
            Removes the association between the source and the handler.
            </summary>
            <param name="source">The source.</param>
            <param name="handler">The handler.</param>
        </member>
        <member name="M:ReactiveUI.WeakEventManager`3.DeliverEvent(`0,`2)">
            <summary>
            Delivers the event to the handlers registered for the source. 
            </summary>
            <param name="sender">The sender.</param>
            <param name="args">The <see cref="!:TEventArgs"/> instance containing the event data.</param>
        </member>
        <member name="M:ReactiveUI.WeakEventManager`3.StartListening(System.Object)">
            <summary>
            Override this method to attach to an event.
            </summary>
            <param name="source">The source.</param>
        </member>
        <member name="M:ReactiveUI.WeakEventManager`3.StopListening(System.Object)">
            <summary>
            Override this method to detach from an event.
            </summary>
            <param name="source">The source.</param>
        </member>
        <member name="T:ReactiveUI.AutoLayoutViewModelViewHostLegacy">
            <summary>
            Use this class instead of <see cref="T:ReactiveUI.ViewModelViewHost"/> when
            taking advantage of Auto Layout. This will automatically wire
            up edge constraints for you from the parent view (the target)
            to the child subview.
            </summary>
        </member>
        <member name="T:ReactiveUI.CreatesCommandBindingViaEvent">
            <summary>
            This binder is the default binder for connecting to arbitrary events
            </summary>
        </member>
        <member name="M:ReactiveUI.ExpressionMixins.GetExpressionChain(System.Linq.Expressions.Expression)">
             <summary>
            
             </summary>
             <param name="This"></param>
             <returns></returns>
        </member>
        <member name="M:ReactiveUI.ExpressionMixins.GetMemberInfo(System.Linq.Expressions.Expression)">
             <summary>
            
             </summary>
             <param name="expression"></param>
             <returns></returns>
        </member>
        <member name="M:ReactiveUI.ExpressionMixins.GetParent(System.Linq.Expressions.Expression)">
             <summary>
            
             </summary>
             <param name="expression"></param>
             <returns></returns>
        </member>
        <member name="M:ReactiveUI.ExpressionMixins.GetArgumentsArray(System.Linq.Expressions.Expression)">
             <summary>
            
             </summary>
             <param name="expression"></param>
             <returns></returns>
        </member>
        <member name="P:ReactiveUI.Legacy.IReactiveCommand.CanExecuteObservable">
            <summary>
            Gets a value indicating whether this instance can execute observable.
            </summary>
            <value><c>true</c> if this instance can execute observable; otherwise, <c>false</c>.</value>
        </member>
        <member name="P:ReactiveUI.Legacy.IReactiveCommand.IsExecuting">
            <summary>
            Gets a value indicating whether this instance is executing. This
            Observable is guaranteed to always return a value immediately (i.e.
            it is backed by a BehaviorSubject), meaning it is safe to determine
            the current state of the command via IsExecuting.First()
            </summary>
            <value><c>true</c> if this instance is executing; otherwise, <c>false</c>.</value>
        </member>
        <member name="T:ReactiveUI.Legacy.IReactiveCommand`1">
             <summary>
             IReactiveCommand represents an ICommand which also notifies when it is
             executed (i.e. when Execute is called) via IObservable. Conceptually,
             this represents an Event, so as a result this IObservable should never
             OnComplete or OnError.
            
             In previous versions of ReactiveUI, this interface was split into two
             separate interfaces, one to handle async methods and one for "standard"
             commands, but these have now been merged - every ReactiveCommand is now
             a ReactiveAsyncCommand.
             </summary>
        </member>
        <member name="M:ReactiveUI.Legacy.ReactiveCommand.Create(System.IObservable{System.Boolean},System.Reactive.Concurrency.IScheduler)">
            <summary>
            Creates a default ReactiveCommand that has no background action. This
            is probably what you want if you were calling the constructor in
            previous versions of ReactiveUI
            </summary>
            <param name="canExecute">An Observable that determines when the
            Command can Execute. WhenAny is a great way to create this!</param>
            <param name="scheduler">The scheduler to deliver events on.
            Defaults to RxApp.MainThreadScheduler.</param>
            <returns>A ReactiveCommand whose ExecuteAsync just returns the
            CommandParameter immediately. Which you should ignore!</returns>
        </member>
        <member name="M:ReactiveUI.Legacy.ReactiveCommand.CreateAsyncObservable``1(System.IObservable{System.Boolean},System.Func{System.Object,System.IObservable{``0}},System.Reactive.Concurrency.IScheduler)">
            <summary>
            Creates a ReactiveCommand typed to the given executeAsync Observable
            method. Use this method if your background method returns IObservable.
            </summary>
            <param name="canExecute">An Observable that determines when the
            Command can Execute. WhenAny is a great way to create this!</param>
            <param name="executeAsync">Method to call that creates an Observable
            representing an operation to execute in the background. The Command's
            CanExecute will be false until this Observable completes. If this
            Observable terminates with OnError, the Exception is marshaled to
            ThrownExceptions.</param>
            <param name="scheduler">The scheduler to deliver events on.
            Defaults to RxApp.MainThreadScheduler.</param>
            <returns>A ReactiveCommand which returns all items that are created via
            calling executeAsync as a single stream.</returns>
        </member>
        <member name="M:ReactiveUI.Legacy.ReactiveCommand.CreateAsyncObservable``1(System.Func{System.Object,System.IObservable{``0}},System.Reactive.Concurrency.IScheduler)">
            <summary>
            Creates a ReactiveCommand typed to the given executeAsync Observable
            method. Use this method if your background method returns IObservable.
            </summary>
            <param name="executeAsync">Method to call that creates an Observable
            representing an operation to execute in the background. The Command's
            CanExecute will be false until this Observable completes. If this
            Observable terminates with OnError, the Exception is marshaled to
            ThrownExceptions.</param>
            <param name="scheduler">The scheduler to deliver events on.
            Defaults to RxApp.MainThreadScheduler.</param>
            <returns>A ReactiveCommand which returns all items that are created via
            calling executeAsync as a single stream.</returns>
        </member>
        <member name="M:ReactiveUI.Legacy.ReactiveCommand.CreateAsyncTask``1(System.IObservable{System.Boolean},System.Func{System.Object,System.Threading.Tasks.Task{``0}},System.Reactive.Concurrency.IScheduler)">
            <summary>
            Creates a ReactiveCommand typed to the given executeAsync Task-based
            method. Use this method if your background method returns Task or uses
            async/await.
            </summary>
            <param name="canExecute">An Observable that determines when the
            Command can Execute. WhenAny is a great way to create this!</param>
            <param name="executeAsync">Method to call that creates a Task
            representing an operation to execute in the background. The Command's
            CanExecute will be false until this Task completes. If this
            Task terminates with an Exception, the Exception is marshaled to
            ThrownExceptions.</param>
            <param name="scheduler">The scheduler to deliver events on.
            Defaults to RxApp.MainThreadScheduler.</param>
            <returns>A ReactiveCommand which returns all items that are created via
            calling executeAsync as a single stream.</returns>
        </member>
        <member name="M:ReactiveUI.Legacy.ReactiveCommand.CreateAsyncTask``1(System.Func{System.Object,System.Threading.Tasks.Task{``0}},System.Reactive.Concurrency.IScheduler)">
            <summary>
            Creates a ReactiveCommand typed to the given executeAsync Task-based
            method. Use this method if your background method returns Task or uses
            async/await.
            </summary>
            <param name="executeAsync">Method to call that creates a Task
            representing an operation to execute in the background. The Command's
            CanExecute will be false until this Task completes. If this
            Task terminates with an Exception, the Exception is marshaled to
            ThrownExceptions.</param>
            <param name="scheduler">The scheduler to deliver events on.
            Defaults to RxApp.MainThreadScheduler.</param>
            <returns>A ReactiveCommand which returns all items that are created via
            calling executeAsync as a single stream.</returns>
        </member>
        <member name="M:ReactiveUI.Legacy.ReactiveCommand.CreateAsyncTask(System.Func{System.Object,System.Threading.Tasks.Task},System.Reactive.Concurrency.IScheduler)">
            <summary>
            Creates a ReactiveCommand typed to the given executeAsync Task-based
            method. Use this method if your background method returns Task or uses
            async/await.
            </summary>
            <param name="executeAsync">Method to call that creates a Task
            representing an operation to execute in the background. The Command's
            CanExecute will be false until this Task completes. If this
            Task terminates with an Exception, the Exception is marshaled to
            ThrownExceptions.</param>
            <param name="scheduler">The scheduler to deliver events on.
            Defaults to RxApp.MainThreadScheduler.</param>
            <returns>A ReactiveCommand which returns all items that are created via
            calling executeAsync as a single stream.</returns>
        </member>
        <member name="M:ReactiveUI.Legacy.ReactiveCommand.CreateAsyncTask(System.IObservable{System.Boolean},System.Func{System.Object,System.Threading.Tasks.Task},System.Reactive.Concurrency.IScheduler)">
            <summary>
            Creates a ReactiveCommand typed to the given executeAsync Task-based
            method. Use this method if your background method returns Task or uses
            async/await.
            </summary>
            <param name="canExecute">An Observable that determines when the
            Command can Execute. WhenAny is a great way to create this!</param>
            <param name="executeAsync">Method to call that creates a Task
            representing an operation to execute in the background. The Command's
            CanExecute will be false until this Task completes. If this
            Task terminates with an Exception, the Exception is marshaled to
            ThrownExceptions.</param>
            <param name="scheduler">The scheduler to deliver events on.
            Defaults to RxApp.MainThreadScheduler.</param>
            <returns>A ReactiveCommand which returns all items that are created via
            calling executeAsync as a single stream.</returns>
        </member>
        <member name="M:ReactiveUI.Legacy.ReactiveCommand.CreateAsyncTask``1(System.IObservable{System.Boolean},System.Func{System.Object,System.Threading.CancellationToken,System.Threading.Tasks.Task{``0}},System.Reactive.Concurrency.IScheduler)">
            <summary>
            Creates a ReactiveCommand typed to the given executeAsync Task-based
            method that supports cancellation. Use this method if your background
            method returns Task or uses async/await.
            </summary>
            <param name="canExecute">An Observable that determines when the
            Command can Execute. WhenAny is a great way to create this!</param>
            <param name="executeAsync">Method to call that creates a Task
            representing an operation to execute in the background. The Command's
            CanExecute will be false until this Task completes. If this
            Task terminates with an Exception, the Exception is marshaled to
            ThrownExceptions.</param>
            <param name="scheduler">The scheduler to deliver events on.
            Defaults to RxApp.MainThreadScheduler.</param>
            <returns>A ReactiveCommand which returns all items that are created via
            calling executeAsync as a single stream.</returns>
        </member>
        <member name="M:ReactiveUI.Legacy.ReactiveCommand.CreateAsyncTask``1(System.Func{System.Object,System.Threading.CancellationToken,System.Threading.Tasks.Task{``0}},System.Reactive.Concurrency.IScheduler)">
            <summary>
            Creates a ReactiveCommand typed to the given executeAsync Task-based
            method that supports cancellation. Use this method if your background
            method returns Task or uses async/await.
            </summary>
            <param name="executeAsync">Method to call that creates a Task
            representing an operation to execute in the background. The Command's
            CanExecute will be false until this Task completes. If this
            Task terminates with an Exception, the Exception is marshaled to
            ThrownExceptions.</param>
            <param name="scheduler">The scheduler to deliver events on.
            Defaults to RxApp.MainThreadScheduler.</param>
            <returns>A ReactiveCommand which returns all items that are created via
            calling executeAsync as a single stream.</returns>
        </member>
        <member name="M:ReactiveUI.Legacy.ReactiveCommand.CreateAsyncTask(System.Func{System.Object,System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Reactive.Concurrency.IScheduler)">
            <summary>
            Creates a ReactiveCommand typed to the given executeAsync Task-based
            method that supports cancellation. Use this method if your background
            method returns Task or uses async/await.
            </summary>
            <param name="canExecute">An Observable that determines when the
            Command can Execute. WhenAny is a great way to create this!</param>
            <param name="executeAsync">Method to call that creates a Task
            representing an operation to execute in the background. The Command's
            CanExecute will be false until this Task completes. If this
            Task terminates with an Exception, the Exception is marshaled to
            ThrownExceptions.</param>
            <param name="scheduler">The scheduler to deliver events on.
            Defaults to RxApp.MainThreadScheduler.</param>
            <returns>A ReactiveCommand which returns all items that are created via
            calling executeAsync as a single stream.</returns>
        </member>
        <member name="M:ReactiveUI.Legacy.ReactiveCommand.CreateAsyncTask(System.IObservable{System.Boolean},System.Func{System.Object,System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Reactive.Concurrency.IScheduler)">
            <summary>
            Creates a ReactiveCommand typed to the given executeAsync Task-based
            method that supports cancellation. Use this method if your background
            method returns Task or uses async/await.
            </summary>
            <param name="executeAsync">Method to call that creates a Task
            representing an operation to execute in the background. The Command's
            CanExecute will be false until this Task completes. If this
            Task terminates with an Exception, the Exception is marshaled to
            ThrownExceptions.</param>
            <param name="scheduler">The scheduler to deliver events on.
            Defaults to RxApp.MainThreadScheduler.</param>
            <returns>A ReactiveCommand which returns all items that are created via
            calling executeAsync as a single stream.</returns>
        </member>
        <member name="M:ReactiveUI.Legacy.ReactiveCommand.CreateCombined(System.IObservable{System.Boolean},ReactiveUI.Legacy.IReactiveCommand[])">
            <summary>
            This creates a ReactiveCommand that calls several child
            ReactiveCommands when invoked. Its CanExecute will match the
            combined result of the child CanExecutes (i.e. if any child
            commands cannot execute, neither can the parent)
            </summary>
            <param name="canExecute">An Observable that determines whether the
            parent command can execute</param>
            <param name="commands">The commands to combine.</param>
        </member>
        <member name="M:ReactiveUI.Legacy.ReactiveCommand.CreateCombined(ReactiveUI.Legacy.IReactiveCommand[])">
            <summary>
            This creates a ReactiveCommand that calls several child
            ReactiveCommands when invoked. Its CanExecute will match the
            combined result of the child CanExecutes (i.e. if any child
            commands cannot execute, neither can the parent)
            </summary>
            <param name="commands">The commands to combine.</param>
        </member>
        <member name="T:ReactiveUI.Legacy.ReactiveCommand`1">
            <summary>
            This class represents a Command that can optionally do a background task.
            The results of the background task (or a signal that the Command has been
            invoked) are delivered by Subscribing to the command itself, since
            ReactiveCommand is itself an Observable. The results of individual
            invocations can be retrieved via the ExecuteAsync method.
            </summary>
        </member>
        <member name="M:ReactiveUI.Legacy.ReactiveCommand`1.#ctor(System.IObservable{System.Boolean},System.Func{System.Object,System.IObservable{`0}},System.Reactive.Concurrency.IScheduler)">
            <summary>
            Don't use this, use ReactiveCommand.CreateXYZ instead
            </summary>
        </member>
        <member name="M:ReactiveUI.Legacy.ReactiveCommand`1.ExecuteAsync(System.Object)">
             <summary>
             Executes a Command and returns the result asynchronously. This method
             makes it *much* easier to test ReactiveCommand, as well as create
             ReactiveCommands who invoke inferior commands and wait on their results.
            
             Note that you **must** Subscribe to the Observable returned by
             ExecuteAsync or else nothing will happen (i.e. ExecuteAsync is lazy)
            
             Note also that the command will be executed, irrespective of the current value
             of the command's canExecute observable.
             </summary>
             <returns>An Observable representing a single invocation of the Command.</returns>
             <param name="parameter">Don't use this.</param>
        </member>
        <member name="M:ReactiveUI.Legacy.ReactiveCommand`1.ExecuteAsyncTask(System.Object,System.Threading.CancellationToken)">
            <summary>
            Executes a Command and returns the result as a Task. This method
            makes it *much* easier to test ReactiveCommand, as well as create
            ReactiveCommands who invoke inferior commands and wait on their results.
            </summary>
            <returns>A Task representing a single invocation of the Command.</returns>
            <param name="parameter">Don't use this.</param>
            <param name="ct">An optional token that can cancel the operation, if
            the operation supports it.</param>
        </member>
        <member name="P:ReactiveUI.Legacy.ReactiveCommand`1.ThrownExceptions">
            <summary>
            Fires whenever an exception would normally terminate ReactiveUI
            internal state.
            </summary>
            <value>The thrown exceptions.</value>
        </member>
        <member name="P:ReactiveUI.Legacy.ReactiveCommand`1.CanExecuteObservable">
            <summary>
            Returns a BehaviorSubject (i.e. an Observable which is guaranteed to
            return at least one value immediately) representing the CanExecute
            state.
            </summary>
        </member>
        <member name="M:ReactiveUI.Legacy.ReactiveCommand`1.Execute(System.Object)">
            <summary>
            Executes a Command. Note that the command will be executed, irrespective of the current value
            of the command's canExecute observable.
            </summary>
        </member>
        <member name="M:ReactiveUI.Legacy.ReactiveCommandMixins.ToCommand(System.IObservable{System.Boolean},System.Reactive.Concurrency.IScheduler)">
            <summary>
            ToCommand is a convenience method for returning a new
            ReactiveCommand based on an existing Observable chain.
            </summary>
            <param name="scheduler">The scheduler to publish events on - default
            is RxApp.MainThreadScheduler.</param>
            <returns>A new ReactiveCommand whose CanExecute Observable is the
            current object.</returns>
        </member>
        <member name="M:ReactiveUI.Legacy.ReactiveCommandMixins.InvokeCommand``1(System.IObservable{``0},System.Windows.Input.ICommand)">
            <summary>
            A utility method that will pipe an Observable to an ICommand (i.e.
            it will first call its CanExecute with the provided value, then if
            the command can be executed, Execute() will be called)
            </summary>
            <param name="command">The command to be executed.</param>
            <returns>An object that when disposes, disconnects the Observable
            from the command.</returns>
        </member>
        <member name="M:ReactiveUI.Legacy.ReactiveCommandMixins.InvokeCommand``2(System.IObservable{``0},ReactiveUI.Legacy.IReactiveCommand{``1})">
            <summary>
            A utility method that will pipe an Observable to an ICommand (i.e.
            it will first call its CanExecute with the provided value, then if
            the command can be executed, Execute() will be called)
            </summary>
            <param name="command">The command to be executed.</param>
            <returns>An object that when disposes, disconnects the Observable
            from the command.</returns>
        </member>
        <member name="M:ReactiveUI.Legacy.ReactiveCommandMixins.InvokeCommand``2(System.IObservable{``0},``1,System.Linq.Expressions.Expression{System.Func{``1,System.Windows.Input.ICommand}})">
            <summary>
            A utility method that will pipe an Observable to an ICommand (i.e.
            it will first call its CanExecute with the provided value, then if
            the command can be executed, Execute() will be called)
            </summary>
            <param name="target">The root object which has the Command.</param>
            <param name="commandProperty">The expression to reference the Command.</param>
            <returns>An object that when disposes, disconnects the Observable
            from the command.</returns>
        </member>
        <member name="M:ReactiveUI.Legacy.ReactiveCommandMixins.InvokeCommand``3(System.IObservable{``0},``2,System.Linq.Expressions.Expression{System.Func{``2,ReactiveUI.Legacy.IReactiveCommand{``1}}})">
            <summary>
            A utility method that will pipe an Observable to an ICommand (i.e.
            it will first call its CanExecute with the provided value, then if
            the command can be executed, Execute() will be called)
            </summary>
            <param name="target">The root object which has the Command.</param>
            <param name="commandProperty">The expression to reference the Command.</param>
            <returns>An object that when disposes, disconnects the Observable
            from the command.</returns>
        </member>
        <member name="M:ReactiveUI.Legacy.ReactiveCommandMixins.OnExecuteCompleted``1(ReactiveUI.Legacy.ReactiveCommand{``0},System.Action{``0},System.Action{System.Exception})">
            <summary>
            A convenience method for subscribing and creating ReactiveCommands
            in the same call. Equivalent to Subscribing to the command, except
            there's no way to release your Subscription but that's probably fine.
            </summary>
        </member>
        <member name="T:ReactiveUI.Legacy.StockUserErrorIcon">
            <summary>
            Describes a stock error icon situation - it is up to the UI to decide
            how to interpret these icons.
            </summary>
        </member>
        <member name="T:ReactiveUI.Legacy.IRecoveryCommand">
            <summary>
            A command that represents a recovery from an error. These commands
            will typically be displayed as buttons in the error dialog.
            </summary>
        </member>
        <member name="P:ReactiveUI.Legacy.IRecoveryCommand.CommandName">
            <summary>
            The command name, typically displayed as the button text.
            </summary>
        </member>
        <member name="P:ReactiveUI.Legacy.IRecoveryCommand.RecoveryResult">
            <summary>
            When the command is invoked and a result is determined, the
            command should set the recovery result to indicate the action the
            throwing code should take.
            </summary>
        </member>
        <member name="T:ReactiveUI.Legacy.RecoveryOptionResult">
            <summary>
            RecoveryOptionResult describes to the code throwing the UserError what
            to do once the error is resolved.
            </summary>
        </member>
        <member name="F:ReactiveUI.Legacy.RecoveryOptionResult.CancelOperation">
            <summary>
            The operation should be cancelled, but it is no longer an error.
            </summary>
        </member>
        <member name="F:ReactiveUI.Legacy.RecoveryOptionResult.RetryOperation">
            <summary>
            The operation should be retried with the same parameters.
            </summary>
        </member>
        <member name="F:ReactiveUI.Legacy.RecoveryOptionResult.FailOperation">
            <summary>
            Recovery failed or not possible, you should rethrow as an
            Exception.
            </summary>
        </member>
        <member name="T:ReactiveUI.Legacy.UserError">
             <summary>
             User Errors are similar to Exceptions, except that they are intended
             to be displayed to the user. As such, your error messages should be
             phrased in a friendly way. When a UserError is thrown, code higher up
             in the stack has a chance to resolve the UserError via a user
             interaction. 
            
             Code can also add "Recovery Options" which resolve user errors: for
             example an "Out of Disk Space" error might have an "Open Explorer"
             recovery option.
             </summary>
        </member>
        <member name="P:ReactiveUI.Legacy.UserError.ContextInfo">
            <summary>
            A Dictionary that allows UserErrors to contain arbitrary
            application data.
            </summary>
        </member>
        <member name="P:ReactiveUI.Legacy.UserError.RecoveryOptions">
            <summary>
            The list of available Recovery Options that will be presented to
            the user to resolve the issue - these usually correspond to
            buttons in the dialog.
            </summary>
        </member>
        <member name="P:ReactiveUI.Legacy.UserError.ErrorMessage">
            <summary>
            The "Newspaper Headline" of the message being conveyed to the
            user. This should be one line, short, and informative.
            </summary>
        </member>
        <member name="P:ReactiveUI.Legacy.UserError.ErrorCauseOrResolution">
            <summary>
            Additional optional information to describe what is happening, or
            the resolution to an information-only error (i.e. a dialog to tell
            the user that something has happened)
            </summary>
        </member>
        <member name="P:ReactiveUI.Legacy.UserError.UserErrorIcon">
            <summary>
            This object is either a custom icon (usually an ImageSource), or
            it can also be a StockUserErrorIcon. It can also be an
            application-defined type that the handlers know to interpret.
            </summary>
        </member>
        <member name="P:ReactiveUI.Legacy.UserError.InnerException">
            <summary>
            Optionally, The actual Exception that warranted throwing the
            UserError.
            </summary>
        </member>
        <member name="M:ReactiveUI.Legacy.UserError.Throw(System.String,System.Exception)">
            <summary>
            Initiate a user interaction (i.e. "Throw the error to the user to
            deal with") - this method is the simplest way to prompt the user
            that an error has occurred.
            </summary>
            <param name="errorMessage">The message to show to the user. The
            upper level handlers registered with RegisterHandler are
            ultimately responsible for displaying this information.</param>
            <param name="innerException">The Exception that was thrown, if
            relevant - this will *not* ever be shown to the user.</param>
            <returns>An Observable representing the action the code should
            attempt to take, if any.</returns>
        </member>
        <member name="M:ReactiveUI.Legacy.UserError.Throw(ReactiveUI.Legacy.UserError)">
            <summary>
            Initiate a user interaction (i.e. "Throw the error to the user to
            deal with"). 
            </summary>
            <param name="error">The UserError to show to the user. The
            upper level handlers registered with RegisterHandler are
            ultimately responsible for displaying this information. </param>
            <returns></returns>
        </member>
        <member name="M:ReactiveUI.Legacy.UserError.RegisterHandler(System.Func{ReactiveUI.Legacy.UserError,System.IObservable{ReactiveUI.Legacy.RecoveryOptionResult}})">
             <summary>
             Register code to handle a UserError. Registered handlers are
             called in reverse order to their registration (i.e. the newest
             handler is called first), and they each have a chance to handle a
             UserError. 
            
             If a Handler cannot resolve a UserError, it should return null
             instead of an Observable result.
             </summary>
             <param name="errorHandler">A method that can handle a UserError,
             usually by presenting it to the user. If the handler cannot handle
             the error, it should return null.</param>
             <returns>An IDisposable which will unregister the handler.</returns>
        </member>
        <member name="M:ReactiveUI.Legacy.UserError.RegisterHandler``1(System.Func{``0,System.IObservable{ReactiveUI.Legacy.RecoveryOptionResult}})">
             <summary>
             Register code to handle a specific type of UserError. Registered
             handlers are called in reverse order to their registration (i.e.
             the newest handler is called first), and they each have a chance
             to handle a UserError. 
            
             If a Handler cannot resolve a UserError, it should return null
             instead of an Observable result.
             </summary>
             <param name="errorHandler">A method that can handle a UserError,
             usually by presenting it to the user. If the handler cannot handle
             the error, it should return null.</param>
             <returns>An IDisposable which will unregister the handler.</returns>
        </member>
        <member name="M:ReactiveUI.Legacy.UserError.RegisterHandler(System.Func{ReactiveUI.Legacy.UserError,System.Threading.Tasks.Task{ReactiveUI.Legacy.RecoveryOptionResult}})">
             <summary>
             Register code to handle a UserError. Registered handlers are
             called in reverse order to their registration (i.e. the newest
             handler is called first), and they each have a chance to handle a
             UserError. 
            
             If a Handler cannot resolve a UserError, it should return null
             instead of an Observable result.
             </summary>
             <param name="errorHandler">A method that can handle a UserError,
             usually by presenting it to the user. If the handler cannot handle
             the error, it should return null.</param>
             <returns>An IDisposable which will unregister the handler.</returns>
        </member>
        <member name="M:ReactiveUI.Legacy.UserError.RegisterHandler``1(System.Func{``0,System.Threading.Tasks.Task{ReactiveUI.Legacy.RecoveryOptionResult}})">
             <summary>
             Register code to handle a specific type of UserError. Registered
             handlers are called in reverse order to their registration (i.e.
             the newest handler is called first), and they each have a chance
             to handle a UserError. 
            
             If a Handler cannot resolve a UserError, it should return null
             instead of an Observable result.
             </summary>
             <param name="errorHandler">A method that can handle a UserError,
             usually by presenting it to the user. If the handler cannot handle
             the error, it should return null.</param>
             <returns>An IDisposable which will unregister the handler.</returns>
        </member>
        <member name="M:ReactiveUI.Legacy.UserError.AddRecoveryOption(ReactiveUI.Legacy.IRecoveryCommand,System.Func{ReactiveUI.Legacy.UserError,System.Boolean})">
            <summary>
            This method is a convenience wrapper around RegisterHandler that
            adds the specified RecoveryCommand to any UserErrors that match
            its filter.
            </summary>
            <param name="command">The RecoveryCommand to add.</param>
            <param name="filter">An optional filter to determine which
            UserErrors to add the command to.</param>
            <returns>An IDisposable which will unregister the handler.</returns>
        </member>
        <member name="M:ReactiveUI.Legacy.UserError.OverrideHandlersForTesting(System.Func{ReactiveUI.Legacy.UserError,System.IObservable{ReactiveUI.Legacy.RecoveryOptionResult}})">
            <summary>
            This method replaces *all* UserError handlers with the specified
            handler. Use it for testing code that may throw UserErrors.
            </summary>
            <param name="errorHandler">The replacement UserError handler.</param>
            <returns>An IDisposable which will unregister the test handler.</returns>
        </member>
        <member name="M:ReactiveUI.Legacy.UserError.OverrideHandlersForTesting(System.Func{ReactiveUI.Legacy.UserError,ReactiveUI.Legacy.RecoveryOptionResult})">
            <summary>
            This method replaces *all* UserError handlers with the specified
            handler. Use it for testing code that may throw UserErrors.
            </summary>
            <param name="errorHandler">The replacement UserError handler.</param>
            <returns>An IDisposable which will unregister the test handler.</returns>
        </member>
        <member name="T:ReactiveUI.Legacy.UnhandledUserErrorException">
            <summary>
            This Exception will be thrown when a UserError is not handled by any
            of the registered handlers.
            </summary>
        </member>
        <member name="T:ReactiveUI.Legacy.RecoveryCommand">
            <summary>
            RecoveryCommand is a straightforward implementation of a recovery
            command - this class represents a command presented to the user
            (usually in the form of a button) that will help resolve or mitigate a
            UserError.
            </summary>
        </member>
        <member name="M:ReactiveUI.Legacy.RecoveryCommand.#ctor(System.String,System.Func{System.Object,ReactiveUI.Legacy.RecoveryOptionResult})">
            <summary>
            Constructs a RecoveryCommand.
            </summary>
            <param name="commandName">The user-visible name of this Command.</param>
            <param name="handler">A convenience handler - equivalent to
            Subscribing to the command and setting the RecoveryResult.</param>
        </member>
        <member name="P:ReactiveUI.Legacy.RecoveryCommand.Ok">
            <summary>
            A default command whose caption is "Ok"
            </summary>
            <value>RetryOperation</value>
        </member>
        <member name="P:ReactiveUI.Legacy.RecoveryCommand.Cancel">
            <summary>
            A default command whose caption is "Cancel"
            </summary>
            <value>FailOperation</value>
        </member>
        <member name="P:ReactiveUI.Legacy.RecoveryCommand.Yes">
            <summary>
            A default command whose caption is "Yes"
            </summary>
            <value>RetryOperation</value>
        </member>
        <member name="P:ReactiveUI.Legacy.RecoveryCommand.No">
            <summary>
            A default command whose caption is "No"
            </summary>
            <value>FailOperation</value>
        </member>
        <member name="P:ReactiveUI.ReactiveSplitViewController.Changing">
            <summary>
            Represents an Observable that fires *before* a property is about to
            be changed.
            </summary>
        </member>
        <member name="P:ReactiveUI.ReactiveSplitViewController.Changed">
            <summary>
            Represents an Observable that fires *after* a property has changed.
            </summary>
        </member>
        <member name="M:ReactiveUI.ReactiveSplitViewController.SuppressChangeNotifications">
            <summary>
            When this method is called, an object will not fire change
            notifications (neither traditional nor Observable notifications)
            until the return value is disposed.
            </summary>
            <returns>An object that, when disposed, reenables change
            notifications.</returns>
        </member>
        <member name="T:ReactiveUI.ViewContractAttribute">
            <summary>
            Allows an additional string to make view resolution more specific than
            just a type. When applied to your <see cref="T:ReactiveUI.IViewFor`1"/> -derived
            View, you can select between different Views for a single ViewModel
            instance.
            </summary>
        </member>
        <member name="M:ReactiveUI.ViewContractAttribute.#ctor(System.String)">
            <summary>
            Constructs the ViewContractAttribute with a specific contract value.
            </summary>
            <param name="contract">The value of the contract for view
            resolution.</param>
        </member>
        <member name="T:ReactiveUI.SingleInstanceViewAttribute">
            <summary>
            Indicates that this View should be constructed _once_ and then used
            every time its ViewModel View is resolved.
            Obviously, this is not supported on Views that may be reused multiple
            times in the Visual Tree.
            </summary>
        </member>
        <member name="M:System.Reactive.Disposables.DisposableMixins.DisposeWith``1(``0,System.Reactive.Disposables.CompositeDisposable)">
            <summary>
            Ensures the provided disposable is disposed with the specified <see cref="T:System.Reactive.Disposables.CompositeDisposable"/>.
            </summary>
            <typeparam name="T">
            The type of the disposable.
            </typeparam>
            <param name="this">
            The disposable.
            </param>
            <param name="compositeDisposable">
            The <see cref="T:System.Reactive.Disposables.CompositeDisposable"/> to which <paramref name="this"/> will be added.
            </param>
            <returns>
            The disposable.
            </returns>
        </member>
        <member name="T:System.Reactive.Linq.Observable`1">
            <summary>
            Provides commonly required, statically-allocated, pre-canned observables.
            </summary>
            <typeparam name="T">
            The observable type.
            </typeparam>
        </member>
        <member name="F:System.Reactive.Linq.Observable`1.Empty">
            <summary>
            An empty observable of type <typeparamref name="T"/>.
            </summary>
        </member>
        <member name="F:System.Reactive.Linq.Observable`1.Never">
            <summary>
            An observable of type <typeparamref name="T"/> that never ticks a value.
            </summary>
        </member>
        <member name="F:System.Reactive.Linq.Observable`1.Default">
            <summary>
            An observable of type <typeparamref name="T"/> that ticks a single, default value.
            </summary>
        </member>
        <member name="T:System.Reactive.Linq.Observables">
            <summary>
            Provides commonly required, statically-allocated, pre-canned observables.
            </summary>
        </member>
        <member name="F:System.Reactive.Linq.Observables.True">
            <summary>
            An observable that ticks a single, Boolean value of <c>true</c>.
            </summary>
        </member>
        <member name="F:System.Reactive.Linq.Observables.False">
            <summary>
            An observable that ticks a single, Boolean value of <c>false</c>.
            </summary>
            <remarks>
            <para>
            This observable is equivalent to <c>Observable&lt;bool&gt;.Default</c>, but is provided for convenience.
            </para>
            </remarks>
        </member>
        <member name="F:System.Reactive.Linq.Observables.Unit">
            <summary>
            An observable that ticks <c>Unit.Default</c> as a single value.</summary>
            <remarks>
            <para>
            This observable is equivalent to <c>Observable&lt;Unit&gt;.Default</c>, but is provided for convenience.
            </para>
            </remarks>
        </member>
    </members>
</doc>
